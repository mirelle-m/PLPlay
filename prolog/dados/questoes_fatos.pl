:- module(stubs, [
    pergunta_mestra/5
]).

% --- Missão 1 ---
pergunta_mestra('M1_Q1', 1, 'Qual das seguintes não é uma característica de uma linguagem de programação conforme definido no documento?', 'Portabilidade', ['Expressividade', 'Portabilidade', 'Universalidade', 'Simplicidade', 'Implementável']).
pergunta_mestra('M1_Q2', 1, 'O que a característica de ''Universalidade'' de uma linguagem de programação implica?', 'Que ela pode resolver qualquer problema que um computador seja capaz de resolver.', ['Que ela deve ser fácil de aprender.', 'Que ela pode resolver apenas problemas matemáticos.', 'Que ela pode resolver qualquer problema que um computador seja capaz de resolver.', 'Que ela deve ser usada por todos os programadores.', 'Que ela só pode ser usada em máquinas de alto desempenho.']).
pergunta_mestra('M1_Q3', 1, 'De acordo com o documento, qual a principal diferença entre uma linguagem de programação e uma linguagem de consulta a banco de dados (query language)?', 'A linguagem de programação precisa dar suporte a recursão, iteração ou desvios.', ['A linguagem de programação precisa dar suporte a recursão, iteração ou desvios.', 'A linguagem de programação é sempre mais antiga.', 'A linguagem de programação é de alto nível.', 'A linguagem de consulta é mais popular.', 'A linguagem de programação é usada apenas para fins comerciais.']).
pergunta_mestra('M1_Q4', 1, 'O que é uma linguagem de programação de baixo nível de acordo com o texto?', 'Uma linguagem com instruções que refletem de forma mais direta as operações em nível de máquina.', ['Uma linguagem com instruções que refletem de forma mais direta as operações em nível de máquina.', 'Uma linguagem com sintaxe complexa e difícil de usar.', 'Uma linguagem com alta portabilidade.', 'Uma linguagem que é mais lenta e consome mais recursos.', 'Uma linguagem projetada para aplicações de IA.']).
pergunta_mestra('M1_Q5', 1, 'Qual é uma das principais desvantagens de usar uma linguagem de programação de baixo nível segundo o documento?', 'Tem pouca portabilidade.', ['É difícil de traduzir para linguagem de máquina.', 'Tem pouca portabilidade.', 'Consome menos recursos do sistema.', 'É mais simples de programar.', 'É a mais eficiente em termos de tempo.']).
pergunta_mestra('M1_Q6', 1, 'Qual linguagem de programação é citada como exemplo de uma LP de baixo nível?', 'Assembly', ['Python', 'Java', 'C++', 'Assembly', 'Pascal']).
pergunta_mestra('M1_Q7', 1, 'Qual das seguintes linguagens é descrita como sendo a primeira a introduzir conceitos de orientação a objetos (OO) como classe e herança?', 'Simula', ['Pascal', 'Fortran', 'C', 'Simula', 'Lisp']).
pergunta_mestra('M1_Q8', 1, 'Qual LP desenvolvida pela IBM na década de 1950 foi voltada para computação numérica e científica e introduziu o conceito de arrays e procedimentos com parâmetros?', 'Fortran', ['Algol-60', 'Pascal', 'C', 'Simula', 'Fortran']).
pergunta_mestra('M1_Q9', 1, 'Qual LP descrita no documento como a primeira puramente orientada a objetos e dinamicamente tipada e oferece suporte a reflexão?', 'Smalltalk', ['Java', 'C', 'C++', 'Smalltalk', 'Simula']).
pergunta_mestra('M1_Q10', 1, 'O documento menciona que a programação estruturada começou a ser introduzida com qual linguagem?', 'Algol-60', ['Algol-60', 'Fortran', 'Simula', 'C', 'Pascal']).
pergunta_mestra('M1_Q11', 1, 'Qual linguagem foi fortemente inspirada em Algol e se tornou a principal para ensino de programação por sua simplicidade e suporte a programação estruturada?', 'Pascal', ['Pascal', 'C', 'Simula', 'Fortran', 'Lisp']).
pergunta_mestra('M1_Q12', 1, 'Qual linguagem projetada para sistemas de informação comerciais é descrita como verborrágica e ainda hoje é ativa?', 'Cobol', ['Java', 'Pascal', 'Cobol', 'Fortran', 'Python']).
pergunta_mestra('M1_Q13', 1, 'Qual linguagem de grande importância histórica foi utilizada para reimplementar o sistema operacional Unix?', 'C', ['C', 'Java', 'Python', 'Fortran', 'Lisp']).
pergunta_mestra('M1_Q14', 1, 'A que estilo de programação a linguagem Lisp de 1958 é precursora?', 'Programação funcional', ['Programação orientada a objetos', 'Programação funcional', 'Programação imperativa', 'Programação estruturada', 'Programação lógica']).
pergunta_mestra('M1_Q15', 1, 'O que a linguagem Algol-60 introduziu para melhorar a legibilidade e o tempo de desenvolvimento de programas?', 'O uso de blocos delimitados de código e escopo.', ['O uso de desvios incondicionais.', 'O uso de linguagens de baixo nível.', 'O uso de blocos delimitados de código e escopo.', 'A introdução da programação puramente orientada a objetos.', 'A ênfase na computação numérica.']).
pergunta_mestra('M1_Q16', 1, 'Qual é o significado da sigla COBOL?', 'Common Business Oriented Language', ['Common Object-Based Online Language', 'Common Business Oriented Language', 'Common Business and Office Language', 'Computer Business Oriented Language', 'Common Block-Oriented Language']).
pergunta_mestra('M1_Q17', 1, 'A qual das seguintes LP o documento se refere como ''Linguagem de Programação em Lógica''?', 'Prolog', ['Lisp', 'Java', 'Python', 'Prolog', 'Smalltalk']).
pergunta_mestra('M1_Q18', 1, 'Qual das seguintes características de uma LP está relacionada à execução em um tempo aceitável para os propósitos de uso da linguagem?', 'Eficiência', ['Eficiência', 'Simplicidade', 'Universalidade', 'Expressividade', 'Implementável']).
pergunta_mestra('M1_Q19', 1, 'Segundo o documento, até os anos 50, quais eram os principais usos dos computadores?', 'Cálculos numéricos.', ['Aplicações de IA.', 'Sistemas de informação comerciais.', 'Cálculos numéricos.', 'Edição de texto.', 'Jogos.']).
pergunta_mestra('M1_Q20', 1, 'Qual das opções abaixo não é uma das características desejáveis em uma LP conforme listado no slide ''Características'' e ''Simplicidade''?', 'Maior poder expressivo que dificulta o aprendizado.', ['Expressividade.', 'Simplicidade.', 'Suporte a abstração.', 'Implementável.', 'Maior poder expressivo que dificulta o aprendizado.']).

% --- Missão 2 ---
pergunta_mestra('M2_Q1', 2, 'O que é uma linguagem de baixo nível segundo o documento?', 'Uma linguagem cujas instruções são escritas utilizando as instruções do microprocessador.', ['Uma linguagem que não precisa de compilador.', 'Uma linguagem com sintaxe complexa e difícil de usar.', 'Uma linguagem cujas instruções são escritas utilizando as instruções do microprocessador.', 'Uma linguagem que suporta vários paradigmas.', 'Uma linguagem que não é universal.']).
pergunta_mestra('M2_Q2', 2, 'Qual das seguintes é uma característica das linguagens de alto nível?', 'Sintaxe mais estruturada e independente da arquitetura do computador.', ['Sintaxe mais estruturada e independente da arquitetura do computador.', 'Baixa portabilidade.', 'Dificuldade de implementação.', 'Instruções que refletem diretamente as operações da máquina.', 'Pouca expressividade.']).
pergunta_mestra('M2_Q3', 2, 'Qual o principal problema das linguagens compiladas mencionado no texto?', 'Problemas com portabilidade e depuração.', ['Baixa eficiência.', 'Problemas com portabilidade e depuração.', 'Lentidão na execução.', 'Maior consumo de memória.', 'Sintaxe muito complexa.']).
pergunta_mestra('M2_Q4', 2, 'De acordo com o documento, qual o papel de um compilador?', 'Traduzir um programa de uma linguagem para outra semanticamente equivalente.', ['Executar o programa diretamente.', 'Converter a linguagem de máquina em código fonte.', 'Apenas verificar erros de sintaxe.', 'Traduzir um programa de uma linguagem para outra semanticamente equivalente.', 'Tornar o programa mais eficiente.']).
pergunta_mestra('M2_Q5', 2, 'Qual das seguintes é uma vantagem das linguagens interpretadas?', 'Flexibilidade, portabilidade e facilidade para prototipação.', ['Maior eficiência.', 'Flexibilidade, portabilidade e facilidade para prototipação.', 'Menor consumo de memória.', 'Tradução direta para código de máquina.', 'Sintaxe mais simples.']).
pergunta_mestra('M2_Q6', 2, 'Qual é a primeira fase da compilação de acordo com o exemplo?', 'Análise Léxica.', ['Tradução para linguagem de montagem.', 'Análise Semântica.', 'Análise Sintática.', 'Tradução para linguagem intermediária.', 'Análise Léxica.']).
pergunta_mestra('M2_Q7', 2, 'O que é ''semântica'' de um programa?', 'O significado do programa.', ['O significado do programa.', 'O formato do programa.', 'A sua capacidade de ser compilado.', 'O uso de variáveis mutáveis.', 'O número de linhas de código.']).
pergunta_mestra('M2_Q8', 2, 'Qual das linguagens a seguir é citada como um exemplo de LP compilada estaticamente?', 'C++', ['Python', 'Java', 'PHP', 'C#', 'C++']).
pergunta_mestra('M2_Q9', 2, 'De acordo com o diagrama de paradigmas, quais são as duas grandes categorias de paradigmas?', 'Imperativo e Declarativo.', ['Estruturado e Orientado a objetos.', 'Funcional e Lógico.', 'Imperativo e Declarativo.', 'Concorrente e Estruturado.', 'Imperativo e Funcional.']).
pergunta_mestra('M2_Q10', 2, 'Qual dos paradigmas listados a seguir é uma subcategoria do paradigma Imperativo?', 'Estruturado.', ['Estruturado.', 'Lógico.', 'Funcional.', 'Concorrente.', 'Orientado a objetos.']).
pergunta_mestra('M2_Q11', 2, 'Qual das linguagens é um exemplo de paradigma puramente lógico?', 'Prolog', ['Lisp', 'C++', 'Java', 'Python', 'Prolog']).
pergunta_mestra('M2_Q12', 2, 'Que paradigma de LP é definido por ''objeto, mensagem''?', 'Paradigma orientado a objetos.', ['Paradigma funcional.', 'Paradigma orientado a objetos.', 'Paradigma lógico.', 'Paradigma concorrente.', 'Paradigma imperativo.']).
pergunta_mestra('M2_Q13', 2, 'Qual é a principal desvantagem de linguagens interpretadas?', 'Ineficiência e maior consumo de memória.', ['Problemas com portabilidade.', 'Dificuldade para prototipação.', 'Ineficiência e maior consumo de memória.', 'Sintaxe complexa.', 'Falta de flexibilidade.']).
pergunta_mestra('M2_Q14', 2, 'Qual das linguagens a seguir é um exemplo de LP interpretada?', 'Java.', ['Java.', 'C.', 'Fortran.', 'Pascal.', 'Assembly.']).
pergunta_mestra('M2_Q15', 2, 'A qual fase da compilação se refere a transformação de caracteres em tokens?', 'Análise léxica.', ['Análise sintática.', 'Análise semântica.', 'Tradução para linguagem de montagem.', 'Análise léxica.', 'Tradução para linguagem intermediária.']).
pergunta_mestra('M2_Q16', 2, 'De acordo com o documento, o que é a sintaxe de um programa?', 'O formato do programa e como suas construções devem ser arranjadas.', ['O significado do programa.', 'O formato do programa e como suas construções devem ser arranjadas.', 'A sua eficiência.', 'A sua capacidade de ser interpretado.', 'A sua universalidade.']).
pergunta_mestra('M2_Q17', 2, 'Qual é a definição do paradigma funcional?', 'Função, aplicação, avaliação.', ['Relação, dedução.', 'Estado, atribuição, sequência.', 'Objeto, mensagem.', 'Processo, comunicação.', 'Função, aplicação, avaliação.']).
pergunta_mestra('M2_Q18', 2, 'Um programa sintaticamente correto é sempre semanticamente correto?', 'Não, pois podem ocorrer erros de significado.', ['Sim, sempre.', 'Sim, se for compilado.', 'Sim, se for interpretado.', 'Não, pois podem ocorrer erros de significado.', 'Sim, desde que não tenha erros de digitação.']).
pergunta_mestra('M2_Q19', 2, 'Qual das seguintes é uma forma de apresentar a semântica de uma linguagem?', 'Semântica Axiomática.', ['Sintaxe de Backus Naur (BNF).', 'Fase de análise léxica.', 'Semântica Axiomática.', 'Análise sintática.', 'Fase de tradução.']).
pergunta_mestra('M2_Q20', 2, 'Qual das linguagens a seguir é classificada como multiparadigma por combinar funcional e OO?', 'Ocaml', ['Java', 'C++', 'Ada', 'Ocaml', 'Prolog']).

% --- Missão 3 ---
pergunta_mestra('M3_Q1', 3, 'O que são valores de ''primeira classe'' em uma LP?', 'Valores que não possuem restrições para seu uso como argumentos ou retorno de funções.', ['Valores que não podem ser passados como argumento.', 'Valores que não possuem restrições para seu uso como argumentos ou retorno de funções.', 'Valores que são sempre do tipo inteiro.', 'Valores que são sempre mutáveis.', 'Valores que só existem em tempo de compilação.']).
pergunta_mestra('M3_Q2', 3, 'Em linguagens como C, strings e arrays são exemplos de valores de qual classe?', 'Segunda classe', ['Primeira classe', 'Terceira classe', 'Sem classe', 'Classe indefinida', 'Segunda classe']).
pergunta_mestra('M3_Q3', 3, 'Qual o principal objetivo dos ''Sistemas de Tipos'' em LPs?', 'Determinar a qual tipo os valores e expressões pertencem em tempo de execução.', ['Determinar a qual tipo os valores e expressões pertencem em tempo de execução.', 'Aumentar a complexidade do código.', 'Diminuir a expressividade da linguagem.', 'Acelerar a tradução de código para linguagem de máquina.', 'Permitir o uso de polimorfismo ad-hoc.']).
pergunta_mestra('M3_Q4', 3, 'Qual é a principal desvantagem dos sistemas de tipo mais antigos, onde toda variável e parâmetro precisava de uma declaração com tipo específico?', 'Pouca reusabilidade de código e programação engessada.', ['Maior flexibilidade.', 'Pouca segurança de tipo.', 'Alto desempenho.', 'Pouca reusabilidade de código e programação engessada.', 'Sintaxe simples.']).
pergunta_mestra('M3_Q5', 3, 'O que é monomorfismo?', 'Quando toda entidade tem um único tipo específico associado.', ['Quando uma entidade pode ter vários tipos associados.', 'Quando um programa é semanticamente incorreto.', 'Quando toda entidade tem um único tipo específico associado.', 'Quando uma função retorna outra função.', 'Quando uma linguagem é fracamente tipada.']).
pergunta_mestra('M3_Q6', 3, 'Qual é o problema do monomorfismo na construção de programas?', 'Diminui a flexibilidade na construção de componentes reusáveis.', ['Aumenta a segurança de tipo.', 'Diminui a flexibilidade na construção de componentes reusáveis.', 'Acelera o tempo de compilação.', 'Aumenta a expressividade.', 'Permite o uso de polimorfismo.']).
pergunta_mestra('M3_Q7', 3, 'O que é polimorfismo?', 'Abstrações que operam de maneira uniforme sobre valores de tipos diferentes.', ['Abstrações que operam de maneira uniforme sobre valores de tipos diferentes.', 'Entidades que só podem ter um tipo específico.', 'Linguagens que não têm verificação de tipos.', 'Programas que não são compiláveis.', 'Valores de segunda classe.']).
pergunta_mestra('M3_Q8', 3, 'De acordo com a classificação do polimorfismo, qual tipo é dividido em ''Sobrecarga'' e ''Coerção''?', 'Polimorfismo Ad-hoc.', ['Polimorfismo Universal.', 'Polimorfismo Paramétrico.', 'Polimorfismo de Inclusão.', 'Polimorfismo de Herança.', 'Polimorfismo Ad-hoc.']).
pergunta_mestra('M3_Q9', 3, 'O que caracteriza o polimorfismo por sobrecarga?', 'Um identificador se aplica a mais de uma operação.', ['Um identificador aplica-se a uma única operação.', 'Um identificador se aplica a mais de uma operação.', 'O tipo de uma variável pode ser alterado durante a execução.', 'A linguagem não tem verificação de tipos.', 'Uma função retorna uma lista.']).
pergunta_mestra('M3_Q10', 3, 'Qual é a principal característica da sobrecarga de operadores?', 'O comportamento é alterado de acordo com os tipos dos operandos.', ['O comportamento é alterado de acordo com os tipos dos operandos.', 'O número de operandos é fixo.', 'O operador é ignorado.', 'A ordem dos operandos não importa.', 'O resultado é sempre um inteiro.']).
pergunta_mestra('M3_Q11', 3, 'O que é a coerção em polimorfismo?', 'Uma conversão implícita de tipo que pode ocorrer para evitar erros de tipo.', ['A capacidade de um objeto ter múltiplos tipos.', 'Um mecanismo que permite a reusabilidade de código.', 'Quando a função é passada como argumento.', 'Uma conversão implícita de tipo que pode ocorrer para evitar erros de tipo.', 'Um erro de tipo que o compilador não detecta.']).
pergunta_mestra('M3_Q12', 3, 'O que é polimorfismo universal?', 'Abstrações que atuam sobre um número infinito de tipos.', ['Abstrações que atuam em um número finito de tipos.', 'Quando a coerção não é permitida.', 'Abstrações que atuam sobre um número infinito de tipos.', 'Quando a sobrecarga de operadores é desativada.', 'O tipo de uma variável não pode ser alterado.']).
pergunta_mestra('M3_Q13', 3, 'Qual das linguagens a seguir é usada como exemplo de polimorfismo de inclusão no documento?', 'Java.', ['Java.', 'Python.', 'Haskell.', 'C.', 'Lisp.']).
pergunta_mestra('M3_Q14', 3, 'O polimorfismo de inclusão caracteriza uma relação entre o que?', 'Implementações e reuso de código.', ['Tipos e classes.', 'Implementações e reuso de código.', 'Funções e variáveis.', 'Compiladores e interpretadores.', 'Sintaxe e semântica.']).
pergunta_mestra('M3_Q15', 3, 'O que é polimorfismo paramétrico?', 'Permite que uma abstração seja escrita de forma genérica para atuar sobre diferentes tipos.', ['Uma forma de coerção.', 'Um tipo de herança.', 'Uma forma de sobrecarga.', 'Permite que uma abstração seja escrita de forma genérica para atuar sobre diferentes tipos.', 'A capacidade de um tipo ser de primeira classe.']).
pergunta_mestra('M3_Q16', 3, 'Qual é o tipo de polimorfismo implementado em Java através de ''Generics''?', 'Polimorfismo paramétrico.', ['Polimorfismo ad-hoc.', 'Polimorfismo por inclusão.', 'Polimorfismo por sobrecarga.', 'Polimorfismo por coerção.', 'Polimorfismo paramétrico.']).
pergunta_mestra('M3_Q17', 3, 'O que é um sistema de tipo estático?', 'A verificação de tipos ocorre durante a compilação.', ['A verificação de tipos ocorre durante a execução.', 'A verificação de tipos é opcional.', 'A verificação de tipos ocorre durante a compilação.', 'A linguagem não tem tipos.', 'A linguagem é puramente funcional.']).
pergunta_mestra('M3_Q18', 3, 'Qual a principal vantagem de um sistema de tipo estático?', 'Detecção de erros de tipo em tempo de compilação.', ['Maior flexibilidade.', 'Menor segurança de tipo.', 'Detecção de erros de tipo em tempo de compilação.', 'Maior consumo de memória.', 'Maior portabilidade.']).
pergunta_mestra('M3_Q19', 3, 'Em um sistema de tipo forte e dinâmico, como em Python, qual o possível problema mencionado no texto?', 'O erro de tipo é detectado apenas em tempo de execução.', ['O código não pode ser compilado.', 'O erro de tipo é detectado apenas em tempo de execução.', 'A linguagem é fracamente tipada.', 'Não há polimorfismo.', 'O código é difícil de ler.']).
pergunta_mestra('M3_Q20', 3, 'Qual das seguintes linguagens é um exemplo de sistema de tipo forte e estático?', 'Java', ['Python', 'JavaScript', 'C', 'PHP', 'Java']).

% --- Missão 4 ---
pergunta_mestra('M4_Q1', 4, 'Qual a relação fundamental entre a arquitetura de von Neumann e o projeto de linguagens imperativas?', 'A maioria das linguagens imperativas populares foram projetadas em torno da arquitetura de von Neumann, que influencia o uso de variáveis e comandos.', ['A arquitetura de von Neumann não tem relação com o paradigma imperativo.', 'Linguagens imperativas foram projetadas para arquiteturas de processamento paralelo.', 'A arquitetura de von Neumann inspira linguagens funcionais e não imperativas.', 'A maioria das linguagens imperativas populares foram projetadas em torno da arquitetura de von Neumann, que influencia o uso de variáveis e comandos.', 'A arquitetura de von Neumann foi um modelo que substituiu a arquitetura imperativa.']).
pergunta_mestra('M4_Q2', 4, 'O que é uma variável na programação imperativa, de acordo com o documento?', 'Uma entidade que contém um valor que pode ser avaliado e alterado.', ['Uma entidade que contém um valor que pode ser avaliado e alterado.', 'Uma entidade que só pode ser lida.', 'Uma constante que nunca muda de valor.', 'Uma função que retorna um valor.', 'Uma entidade que só existe em tempo de compilação.']).
pergunta_mestra('M4_Q3', 4, 'Qual a principal diferença entre variáveis ''primitivas'' e ''compostas''?', 'Primitivas armazenam valores de tipos primitivos, enquanto compostas possuem campos que são também variáveis.', ['Primitivas são mais rápidas que compostas.', 'Compostas armazenam apenas números inteiros.', 'Primitivas são alocadas no heap enquanto compostas são no stack.', 'Primitivas armazenam valores de tipos primitivos, enquanto compostas possuem campos que são também variáveis.', 'Primitivas não podem ser alteradas.']).
pergunta_mestra('M4_Q4', 4, 'De acordo com a classificação quanto ao tempo de vida, o que é uma variável ''persistente''?', 'Uma variável que tem existência independente do tempo de vida do programa (arquivos).', ['Uma variável criada e usada apenas dentro de um programa.', 'Uma variável alocada no stack.', 'Uma variável que tem existência independente do tempo de vida do programa (arquivos).', 'Uma variável que não pode ser destruída.', 'Uma variável que muda de valor constantemente.']).
pergunta_mestra('M4_Q5', 4, 'O que é uma ''variável de heap''?', 'Uma variável criada ou inicializada em tempo de execução, com alocação dinâmica de memória.', ['Uma variável criada ou inicializada em tempo de execução, com alocação dinâmica de memória.', 'Uma variável que é sempre declarada e inicializada no início da execução.', 'Uma variável que só armazena tipos primitivos.', 'Uma variável com alocação estática.', 'Uma variável que não pode ser desalocada.']).
pergunta_mestra('M4_Q6', 4, 'Qual a definição de ''tempo de vida'' de uma variável?', 'O intervalo de tempo entre a sua criação (alocação) e a sua destruição (desalocação).', ['O número de linhas de código em que ela é usada.', 'O momento em que ela é declarada.', 'O intervalo de tempo que ela leva para ser inicializada.', 'O tamanho da memória que ela ocupa.', 'O intervalo de tempo entre a sua criação (alocação) e a sua destruição (desalocação).']).
pergunta_mestra('M4_Q7', 4, 'O que são ''referências soltas'' (dangling references)?', 'Apontadores para uma variável de heap que foi desalocada.', ['Apontadores para uma variável de stack desalocada.', 'Apontadores para uma variável de heap que foi desalocada.', 'Variáveis que não têm um valor.', 'Variáveis que são sempre globais.', 'Variáveis de tipos primitivos.']).
pergunta_mestra('M4_Q8', 4, 'O que é ''escopo'' de uma variável?', 'As partes do programa que podem acessar essa variável.', ['O tempo que a variável leva para ser criada.', 'O valor que a variável armazena.', 'As partes do programa que podem acessar essa variável.', 'A sua classificação como primitiva ou composta.', 'O tipo de memória em que a variável é alocada.']).
pergunta_mestra('M4_Q9', 4, 'O que caracteriza o ''escopo dinâmico''?', 'O escopo é determinado pela linha de execução do programa e depende da ordem de execução das rotinas.', ['O escopo é determinado pela estrutura textual do programa.', 'O escopo de uma variável não pode ser alterado.', 'O escopo é definido antes da execução.', 'O escopo é determinado pela linha de execução do programa e depende da ordem de execução das rotinas.', 'O escopo é sempre global.']).
pergunta_mestra('M4_Q10', 4, 'Qual a principal desvantagem do ''escopo dinâmico'' mencionada no documento?', 'Fica difícil acompanhar quais variáveis estão visíveis e prejudica o encapsulamento.', ['Aumenta a legibilidade.', 'Promove o encapsulamento.', 'Facilita a compreensão do código.', 'É dependente da ordem de declaração das funções.', 'Fica difícil acompanhar quais variáveis estão visíveis e prejudica o encapsulamento.']).
pergunta_mestra('M4_Q11', 4, 'No ''escopo léxico'', o que determina a definição do escopo?', 'A estrutura ''textual'' do programa.', ['A estrutura ''textual'' do programa.', 'A ordem de execução das rotinas.', 'O tipo de dado da variável.', 'A quantidade de memória disponível.', 'O número de chamadas de funções.']).
pergunta_mestra('M4_Q12', 4, 'Qual a principal diferença entre ''expressões'' e ''comandos''?', 'Expressões leem estados e computam valores, enquanto comandos modificam estados.', ['Expressões modificam estados e comandos leem estados.', 'Ambos modificam estados.', 'Ambos leem estados.', 'Comandos são sempre mais complexos que expressões.', 'Expressões leem estados e computam valores, enquanto comandos modificam estados.']).
pergunta_mestra('M4_Q13', 4, 'O que são ''comandos sequenciais''?', 'Um conjunto de comandos executados um após o outro em uma ordem definida.', ['Comandos que são executados sem uma ordem particular.', 'Um conjunto de comandos executados um após o outro em uma ordem definida.', 'Comandos que são executados em paralelo.', 'Comandos que só podem ser usados dentro de loops.', 'Comandos que modificam o estado de forma não-determinística.']).
pergunta_mestra('M4_Q14', 4, 'Qual das opções não é um tipo de comando fundamental listado no documento?', 'Atribuições recursivas.', ['Atribuições recursivas.', 'Atribuições.', 'Chamadas de Procedimento.', 'Comandos sequenciais.', 'Comandos iterativos.']).
pergunta_mestra('M4_Q15', 4, 'O que são ''comandos colaterais''?', 'Um conjunto de comandos não-determinísticos, executados sem uma ordem particular.', ['Comandos que são executados em ordem definida.', 'Comandos que não modificam o estado.', 'Um conjunto de comandos não-determinísticos, executados sem uma ordem particular.', 'Comandos que são usados apenas em programação orientada a objetos.', 'Comandos que não podem ser usados em conjunto.']).
pergunta_mestra('M4_Q16', 4, 'O que ''transparência referencial'' significa para uma linguagem de programação?', 'Qualquer expressão pode ser substituída por outra que tenha o mesmo valor sem impacto.', ['O uso de variáveis globais é proibido.', 'A alocação de memória é sempre estática.', 'Um programa pode ser lido de forma sequencial.', 'Qualquer expressão pode ser substituída por outra que tenha o mesmo valor sem impacto.', 'Uma linguagem com alta portabilidade.']).
pergunta_mestra('M4_Q17', 4, 'Qual o problema de uma linguagem imperativa não ter ''transparência referencial''?', 'A avaliação de uma expressão pode alterar variáveis, impactando o comportamento do sistema.', ['O código é sempre mais conciso.', 'Não existem efeitos colaterais.', 'Um compilador não pode ser usado.', 'O uso de jumps é impossível.', 'A avaliação de uma expressão pode alterar variáveis, impactando o comportamento do sistema.']).
pergunta_mestra('M4_Q18', 4, 'O que é um ''sequenciador''?', 'Uma construção que transfere o controle para outro ponto do programa.', ['Uma construção que transfere o controle para outro ponto do programa.', 'Uma construção que lê valores e não os modifica.', 'Uma variável que só pode ser usada em funções.', 'Uma linguagem de programação com escopo estático.', 'Uma operação de atribuição simples.']).
pergunta_mestra('M4_Q19', 4, 'O que o uso irrestrito de ''jumps'' (goto) pode gerar?', 'Programas do tipo ''spaghetti'' com múltiplas-entradas e múltiplas-saídas.', ['Um fluxo de controle única-entrada, única-saída.', 'Um código mais legível.', 'Um programa sem sequenciadores.', 'Programas do tipo ''spaghetti'' com múltiplas-entradas e múltiplas-saídas.', 'Um fluxo de controle única-entrada, múltiplas-saídas.']).
pergunta_mestra('M4_Q20', 4, 'O que o comando ''break'' em Java representa?', 'Um tipo de ''escape'' que termina a execução de um comando composto.', ['Um comando de atribuição.', 'Um tipo de ''escape'' que termina a execução de um comando composto.', 'Um comando iterativo definido.', 'Um tipo de ''jump'' incondicional.', 'Um comando condicional.']).

% --- Missão 5 ---
pergunta_mestra('M5_Q1', 5, 'Em um sistema de tipagem forte e estático como o de Java, por que o polimorfismo de inclusão (relacionado à herança) é crucial para a reusabilidade de código?', 'Porque permite que um tipo possa ser substituído por um subtipo sem comprometer a segurança de tipo.', ['Porque ele permite a verificação de tipos apenas em tempo de execução.', 'Porque ele torna a linguagem mais fracamente tipada.', 'Porque permite que um tipo possa ser substituído por um subtipo sem comprometer a segurança de tipo.', 'Porque ele é um tipo de polimorfismo ad-hoc.', 'Porque ele ignora a verificação de tipos.']).
pergunta_mestra('M5_Q2', 5, 'Qual a relação entre a linguagem Lisp (Missão 1) e o paradigma funcional (Missão 2)?', 'Lisp é considerada a precursora do paradigma funcional, focando na aplicação e avaliação de funções.', ['Lisp é considerada a precursora do paradigma funcional, focando na aplicação e avaliação de funções.', 'Lisp é uma linguagem puramente imperativa.', 'Lisp é uma linguagem que só utiliza escopo dinâmico.', 'Lisp não tem relação com o paradigma funcional.', 'Lisp é uma linguagem fracamente tipada.']).
pergunta_mestra('M5_Q3', 5, 'A ausência de ''transparência referencial'' nas linguagens imperativas (Missão 4) é uma consequência de qual característica fundamental dessas linguagens?', 'O uso de variáveis mutáveis e comandos que alteram o estado do programa.', ['O uso de polimorfismo.', 'A tipagem estática.', 'A alocação de memória no stack.', 'O uso de variáveis mutáveis e comandos que alteram o estado do programa.', 'O uso de escopo léxico.']).
pergunta_mestra('M5_Q4', 5, 'Por que o uso irrestrito de ''jumps'' (goto) se opõe aos princípios da programação estruturada introduzidos por linguagens como Algol-60 (Missão 1)?', 'Porque ''jumps'' criam um fluxo de controle múltiplas-entradas e múltiplas-saídas, dificultando a compreensão do código.', ['Porque ''jumps'' promovem o encapsulamento.', 'Porque ''jumps'' são exclusivos de linguagens de alto nível.', 'Porque ''jumps'' aumentam a legibilidade do código.', 'Porque ''jumps'' garantem a transparência referencial.', 'Porque ''jumps'' criam um fluxo de controle múltiplas-entradas e múltiplas-saídas, dificultando a compreensão do código.']).
pergunta_mestra('M5_Q5', 5, 'Em um compilador, a ''Análise Léxica'' (Missão 2) transforma o código fonte em tokens. O que a ''Análise Semântica'' (Missão 2) faz em seguida?', 'Verifica o significado do programa, garantindo que as operações e tipos sejam compatíveis.', ['Verifica se o programa está bem formatado.', 'Verifica o significado do programa, garantindo que as operações e tipos sejam compatíveis.', 'Traduz os tokens para linguagem de máquina.', 'Gera código de montagem.', 'Otimiza o código.']).
pergunta_mestra('M5_Q6', 5, 'Qual a relação entre o ''escopo léxico'' (Missão 4) e o conceito de programação estruturada (Missão 1)?', 'Escopo léxico é determinado pela estrutura textual do programa, o que facilita a compreensão e organiza o código em blocos.', ['Escopo léxico é usado apenas em linguagens funcionais.', 'Escopo léxico é determinado pela ordem de execução.', 'Escopo léxico é determinado pela estrutura textual do programa, o que facilita a compreensão e organiza o código em blocos.', 'Escopo léxico não tem relação com a programação estruturada.', 'Escopo léxico é mais difícil de depurar.']).
pergunta_mestra('M5_Q7', 5, 'Considere a linguagem C (Missão 1) com seu sistema de tipo estático (Missão 3). Qual a principal diferença em como ela lida com ''referências soltas'' (Missão 4) em comparação com linguagens com gerenciamento automático de memória?', 'C exige gerenciamento manual de memória, o que aumenta a probabilidade de ''dangling references'' se a memória de heap for desalocada incorretamente.', ['C exige gerenciamento manual de memória, o que aumenta a probabilidade de ''dangling references'' se a memória de heap for desalocada incorretamente.', 'C é uma linguagem de alto nível que previne ''dangling references''.', 'Em C, ''dangling references'' não são um problema.', 'C não tem ponteiros.', 'Em C, as ''dangling references'' são detectadas em tempo de compilação.']).
pergunta_mestra('M5_Q8', 5, 'O que o conceito de ''monomorfismo'' (Missão 3) representa em contraste com a ''expressividade'' de uma LP (Missão 1)?', 'Monomorfismo limita a capacidade de escrever código genérico, diminuindo a expressividade de uma linguagem.', ['Monomorfismo aumenta a expressividade.', 'Monomorfismo não tem relação com a expressividade.', 'Monomorfismo é uma forma de polimorfismo universal.', 'Monomorfismo limita a capacidade de escrever código genérico, diminuindo a expressividade de uma linguagem.', 'Monomorfismo é um erro de compilação.']).
pergunta_mestra('M5_Q9', 5, 'Qual é a principal razão pela qual linguagens interpretadas (Missão 2) são frequentemente mais portáveis que linguagens compiladas (Missão 2)?', 'O interpretador pode ser escrito para diferentes arquiteturas, permitindo que o mesmo código fonte seja executado em múltiplos sistemas.', ['Linguagens interpretadas traduzem o código para código de máquina antes da execução.', 'O interpretador pode ser escrito para diferentes arquiteturas, permitindo que o mesmo código fonte seja executado em múltiplos sistemas.', 'Linguagens interpretadas são sempre mais eficientes.', 'Linguagens interpretadas têm menos recursos.', 'Linguagens interpretadas não têm fases de análise.']).
pergunta_mestra('M5_Q10', 5, 'O que o conceito de ''valores de primeira classe'' (Missão 3) tem em comum com o paradigma funcional (Missão 2)?', 'Permite que funções sejam tratadas como valores, o que é fundamental para o paradigma funcional.', ['Permite que funções sejam tratadas como valores, o que é fundamental para o paradigma funcional.', 'Não há relação entre os dois.', 'Valores de primeira classe são exclusivos de linguagens imperativas.', 'O paradigma funcional não utiliza valores de primeira classe.', 'Valores de primeira classe são sempre mutáveis.']).
pergunta_mestra('M5_Q11', 5, 'Qual a relação entre a arquitetura de von Neumann (Missão 4) e o conceito de ''comandos'' (Missão 4)?', 'Comandos são baseados nas operações de transferência de dados e instruções da arquitetura de von Neumann.', ['A arquitetura de von Neumann não tem comandos.', 'Comandos são a mesma coisa que expressões.', 'Comandos são uma abstração de alto nível que não se relaciona com a máquina.', 'Comandos são baseados nas operações de transferência de dados e instruções da arquitetura de von Neumann.', 'Comandos são usados apenas em linguagens declarativas.']).
pergunta_mestra('M5_Q12', 5, 'O que um sistema de tipagem forte e dinâmico como o de Python (Missão 3) pode permitir em tempo de execução?', 'Uma variável assumir valores de tipos diferentes, o que pode levar a erros de tipo em tempo de execução.', ['Erros de tipo serem detectados em tempo de compilação.', 'Uma variável assumir valores de tipos diferentes, o que pode levar a erros de tipo em tempo de execução.', 'Ponteiros para memória desalocada.', 'Não há polimorfismo.', 'Um código não ser interpretado.']).
pergunta_mestra('M5_Q13', 5, 'Como a ''simplicidade'' de uma LP (Missão 1) se relaciona com a existência de ''efeitos colaterais'' (Missão 4)?', 'A simplicidade de uma linguagem é prejudicada por efeitos colaterais que podem tornar o código mais difícil de entender e depurar.', ['Simplicidade garante que haverá efeitos colaterais.', 'Não há relação entre os dois.', 'A simplicidade de uma linguagem é prejudicada por efeitos colaterais que podem tornar o código mais difícil de entender e depurar.', 'Linguagens simples não têm efeitos colaterais.', 'Efeitos colaterais simplificam o código.']).
pergunta_mestra('M5_Q14', 5, 'Em um programa imperativo, por que o ''tempo de vida'' das variáveis (Missão 4) é uma preocupação?', 'Porque um gerenciamento inadequado da memória pode causar ''dangling references'' ou vazamentos de memória.', ['Porque um gerenciamento inadequado da memória pode causar ''dangling references'' ou vazamentos de memória.', 'Porque o tempo de vida não tem relação com a alocação de memória.', 'Porque o tempo de vida é sempre estático.', 'Porque o tempo de vida é determinado pelo escopo dinâmico.', 'Porque o tempo de vida é gerenciado automaticamente em todas as linguagens.']).
pergunta_mestra('M5_Q15', 5, 'O que diferencia o paradigma imperativo (Missão 2) do paradigma declarativo (Missão 2)?', 'O paradigma imperativo foca em como resolver um problema através de uma sequência de comandos, enquanto o declarativo foca em descrever o que se quer como resultado.', ['O paradigma imperativo descreve o que fazer, enquanto o declarativo descreve como fazer.', 'O paradigma declarativo não usa variáveis.', 'O paradigma declarativo é sempre interpretado.', 'O paradigma imperativo foca em como resolver um problema através de uma sequência de comandos, enquanto o declarativo foca em descrever o que se quer como resultado.', 'O paradigma imperativo é mais eficiente.']).
pergunta_mestra('M5_Q16', 5, 'Qual a relação entre a ''análise sintática'' de um compilador (Missão 2) e a gramática de uma LP (Missão 2)?', 'A análise sintática verifica se a estrutura do programa está em conformidade com as regras definidas pela gramática.', ['A análise sintática verifica o significado do programa.', 'A análise sintática traduz o programa.', 'A gramática é usada na análise léxica.', 'Não há relação entre eles.', 'A análise sintática verifica se a estrutura do programa está em conformidade com as regras definidas pela gramática.']).
pergunta_mestra('M5_Q17', 5, 'Qual tipo de polimorfismo (Missão 3) se aproxima mais da ideia de ''sobrecarga'' (Missão 3)?', 'Polimorfismo ad-hoc.', ['Polimorfismo paramétrico.', 'Polimorfismo ad-hoc.', 'Polimorfismo de inclusão.', 'Polimorfismo universal.', 'Monomorfismo.']).
pergunta_mestra('M5_Q18', 5, 'Como a ''eficiência'' de uma LP (Missão 1) se relaciona com a escolha entre uma linguagem compilada ou interpretada (Missão 2)?', 'Linguagens compiladas tendem a ser mais eficientes, pois a tradução para código de máquina é feita antes da execução.', ['Linguagens compiladas tendem a ser mais eficientes, pois a tradução para código de máquina é feita antes da execução.', 'Linguagens interpretadas são sempre mais eficientes.', 'A eficiência não depende da forma de tradução.', 'Linguagens compiladas têm menor portabilidade.', 'Linguagens interpretadas não consomem memória.']).
pergunta_mestra('M5_Q19', 5, 'Em uma linguagem com ''escopo dinâmico'' (Missão 4), o que determina o acesso a uma variável local?', 'A sequência de chamadas de rotinas durante a execução.', ['A estrutura textual do programa.', 'O tipo da variável.', 'A sua alocação no stack.', 'A sequência de chamadas de rotinas durante a execução.', 'A sua alocação no heap.']).
pergunta_mestra('M5_Q20', 5, 'Qual a principal diferença entre ''expressões'' e ''comandos'' no contexto do paradigma imperativo (Missão 4) e como isso se relaciona com a ''transparência referencial''?', 'Comandos modificam o estado (causando efeitos colaterais), enquanto expressões apenas computam um valor, e a transparência referencial só é possível para expressões.', ['Comandos retornam valores e expressões modificam estados.', 'Ambos são transparentes referencialmente.', 'Comandos não podem ter efeitos colaterais.', 'Expressões causam efeitos colaterais.', 'Comandos modificam o estado (causando efeitos colaterais), enquanto expressões apenas computam um valor, e a transparência referencial só é possível para expressões.']).

% --- Missão 6 ---
pergunta_mestra('M6_Q1', 6, 'Qual a principal característica do paradigma funcional?', 'Trata a computação como a avaliação de funções matemáticas e evita estados mutáveis.', ['Utiliza comandos que modificam o estado do programa.', 'Foca em como resolver um problema passo a passo.', 'Trata a computação como a avaliação de funções matemáticas e evita estados mutáveis.', 'É um estilo de programação que se baseia em herança e polimorfismo.', 'É um paradigma que se baseia em consultas a uma base de fatos.']).
pergunta_mestra('M6_Q2', 6, 'O que é uma ''função pura'' no paradigma funcional?', 'Uma função cujo resultado depende apenas de seus argumentos e não possui efeitos colaterais.', ['Uma função que pode ter efeitos colaterais.', 'Uma função cujo resultado depende apenas de seus argumentos e não possui efeitos colaterais.', 'Uma função que sempre retorna um valor booleano.', 'Uma função que só pode ser usada uma vez.', 'Uma função que manipula variáveis globais.']).
pergunta_mestra('M6_Q3', 6, 'Qual o papel da ''imutabilidade'' no paradigma funcional?', 'Variáveis e estruturas de dados não podem ser alteradas após a criação, o que previne efeitos colaterais.', ['Torna o código mais difícil de entender.', 'Aumenta a complexidade do gerenciamento de memória.', 'Apenas tipos primitivos são imutáveis.', 'Não é um conceito importante no paradigma.', 'Variáveis e estruturas de dados não podem ser alteradas após a criação, o que previne efeitos colaterais.']).
pergunta_mestra('M6_Q4', 6, 'O que ''transparência referencial'' significa no contexto de uma linguagem funcional?', 'Que uma expressão pode ser substituída por seu valor sem alterar o comportamento do programa.', ['Que a linguagem não utiliza funções.', 'Que o código é sempre mais conciso.', 'Que a avaliação de uma expressão pode alterar o estado do programa.', 'Que uma expressão pode ser substituída por seu valor sem alterar o comportamento do programa.', 'Que todas as funções são impuras.']).
pergunta_mestra('M6_Q5', 6, 'O que é uma ''função de ordem superior'' (higher-order function)?', 'Uma função que pode receber outras funções como argumentos ou retornar uma função como resultado.', ['Uma função que não pode ser passada como argumento.', 'Uma função que não pode retornar outra função.', 'Uma função que opera apenas em números inteiros.', 'Uma função que tem apenas um argumento.', 'Uma função que pode receber outras funções como argumentos ou retornar uma função como resultado.']).
pergunta_mestra('M6_Q6', 6, 'Por que a ''recursão'' é a principal forma de iteração no paradigma funcional?', 'Porque o estado mutável é evitado e a recursão não depende de variáveis de controle de loop.', ['Porque a programação funcional usa comandos de atribuição e loops.', 'Porque a recursão é menos eficiente que loops.', 'Porque a recursão é a única maneira de criar efeitos colaterais.', 'Porque o estado mutável é evitado e a recursão não depende de variáveis de controle de loop.', 'Porque linguagens funcionais não suportam funções.']).
pergunta_mestra('M6_Q7', 6, 'Qual a função do ''lambda calculus'' no paradigma funcional?', 'É a base teórica para a computação funcional.', ['É a principal forma de iteração.', 'É a base teórica para a computação funcional.', 'É um sistema de tipos para linguagens funcionais.', 'É um tipo de polimorfismo.', 'É uma linguagem de programação imperativa.']).
pergunta_mestra('M6_Q8', 6, 'Qual das seguintes linguagens é um exemplo de linguagem puramente funcional?', 'Haskell', ['Java', 'Python', 'C', 'Haskell', 'Javascript']).
pergunta_mestra('M6_Q9', 6, 'Qual a principal desvantagem de funções com ''efeitos colaterais''?', 'Elas tornam o código mais difícil de raciocinar, testar e paralelizar.', ['Elas são mais fáceis de testar.', 'Elas aumentam a transparência referencial.', 'Elas tornam o código mais difícil de raciocinar, testar e paralelizar.', 'Elas são essenciais para o paradigma funcional.', 'Elas não podem receber argumentos.']).
pergunta_mestra('M6_Q10', 6, 'O que é ''avaliação preguiçosa'' (lazy evaluation)?', 'As expressões só são avaliadas quando seu valor é realmente necessário.', ['Todas as expressões são avaliadas imediatamente.', 'É um tipo de sobrecarga de operadores.', 'É um recurso exclusivo de linguagens imperativas.', 'As funções não podem ser avaliadas.', 'As expressões só são avaliadas quando seu valor é realmente necessário.']).
pergunta_mestra('M6_Q11', 6, 'O que é ''currying'' em programação funcional?', 'A prática de converter uma função que aceita vários argumentos em uma sequência de funções que aceitam um único argumento.', ['A prática de passar todos os argumentos de uma função de uma vez só.', 'Um tipo de polimorfismo.', 'Um erro de compilação.', 'A prática de converter uma função que aceita vários argumentos em uma sequência de funções que aceitam um único argumento.', 'Um tipo de estrutura de dados.']).
pergunta_mestra('M6_Q12', 6, 'Qual das seguintes afirmações é verdadeira sobre o estado no paradigma funcional?', 'O estado é evitado e representado como o valor de retorno de funções.', ['O estado é central e constantemente modificado.', 'O estado é evitado e representado como o valor de retorno de funções.', 'O estado é gerenciado por comandos de atribuição.', 'O estado é sempre global.', 'O estado não existe.']).
pergunta_mestra('M6_Q13', 6, 'Por que a programação funcional é considerada mais adequada para a programação paralela e concorrente?', 'Porque a ausência de efeitos colaterais elimina a necessidade de bloqueios e mecanismos de sincronização.', ['Porque usa o estado compartilhado.', 'Porque é uma linguagem interpretada.', 'Porque o código não é transparente referencialmente.', 'Porque a ausência de efeitos colaterais elimina a necessidade de bloqueios e mecanismos de sincronização.', 'Porque é uma linguagem puramente imperativa.']).
pergunta_mestra('M6_Q14', 6, 'Qual é a principal diferença entre programação funcional e imperativa?', 'Funcional foca em o que calcular, usando a avaliação de funções. Imperativa foca em como calcular, usando sequências de comandos.', ['Funcional foca em como resolver um problema, enquanto imperativa foca em o que resolver.', 'Imperativa usa funções de ordem superior, enquanto funcional não.', 'Funcional foca em o que calcular, usando a avaliação de funções. Imperativa foca em como calcular, usando sequências de comandos.', 'Não há diferença significativa.', 'Funcional é sempre compilada, enquanto imperativa é sempre interpretada.']).
pergunta_mestra('M6_Q15', 6, 'O que o conceito de ''monads'' permite em linguagens funcionais puras?', 'O tratamento de efeitos colaterais de forma controlada e segura.', ['O uso de variáveis mutáveis.', 'O uso de loops for.', 'O uso de comandos goto.', 'A criação de efeitos colaterais de forma incontrolável.', 'O tratamento de efeitos colaterais de forma controlada e segura.']).
pergunta_mestra('M6_Q16', 6, 'A linguagem Python é considerada puramente funcional?', 'Não, é uma linguagem multiparadigma que incorpora elementos funcionais, mas também tem estado mutável e comandos.', ['Sim, porque ela suporta funções de ordem superior.', 'Sim, porque ela é dinamicamente tipada.', 'Não, é uma linguagem puramente imperativa.', 'Não, é uma linguagem multiparadigma que incorpora elementos funcionais, mas também tem estado mutável e comandos.', 'Sim, porque ela não tem efeitos colaterais.']).
pergunta_mestra('M6_Q17', 6, 'O que é um ''fechamento'' (closure)?', 'Uma função que ''captura'' variáveis de seu escopo circundante, mesmo que o escopo não exista mais.', ['Uma função que ''captura'' variáveis de seu escopo circundante, mesmo que o escopo não exista mais.', 'Um bloco de código que nunca pode ser executado.', 'Uma função que só tem argumentos.', 'Um tipo de dado imutável.', 'Uma estrutura de controle de loop.']).
pergunta_mestra('M6_Q18', 6, 'Qual das seguintes LP não é classificada como sendo funcional?', 'C++', ['Haskell', 'Lisp', 'C++', 'OCaml', 'Erlang']).
pergunta_mestra('M6_Q19', 6, 'Qual a vantagem de usar ''funções puras'' em um código?', 'São fáceis de testar e o seu comportamento é previsível e isolado.', ['Aumentam os efeitos colaterais.', 'São mais difíceis de depurar.', 'Dependem de variáveis globais.', 'Diminuem a transparência referencial.', 'São fáceis de testar e o seu comportamento é previsível e isolado.']).
pergunta_mestra('M6_Q20', 6, 'O que é ''imutabilidade'' em uma estrutura de dados como uma lista ligada?', 'Nenhum elemento da lista pode ser modificado. Para alterações, uma nova lista é criada.', ['Os elementos da lista podem ser modificados a qualquer momento.', 'Nenhum elemento da lista pode ser modificado. Para alterações, uma nova lista é criada.', 'A lista é sempre vazia.', 'A lista é sempre global.', 'A lista só pode ter um elemento.']).

% --- Missão 7 ---
pergunta_mestra('M7_Q1', 7, 'No paradigma funcional, qual a relação entre ''imutabilidade'' e ''transparência referencial''?', 'A imutabilidade é uma condição necessária para alcançar a transparência referencial, pois garante que uma expressão não causará efeitos colaterais.', ['Imutabilidade causa efeitos colaterais.', 'Transparência referencial só existe em linguagens imperativas.', 'Não há relação entre os dois conceitos.', 'A imutabilidade é uma consequência da transparência referencial.', 'A imutabilidade é uma condição necessária para alcançar a transparência referencial, pois garante que uma expressão não causará efeitos colaterais.']).
pergunta_mestra('M7_Q2', 7, 'Por que a ''recursão de cauda'' (tail recursion) é uma otimização importante em linguagens funcionais?', 'Ela permite a transformação de uma chamada recursiva em um loop, evitando o estouro da pilha.', ['Ela não é mais eficiente que a recursão normal.', 'Ela aumenta o consumo de memória.', 'Ela permite a transformação de uma chamada recursiva em um loop, evitando o estouro da pilha.', 'É um recurso exclusivo de linguagens imperativas.', 'Ela aumenta os efeitos colaterais.']).
pergunta_mestra('M7_Q3', 7, 'No paradigma funcional, por que as ''funções puras'' são consideradas ideais para a programação paralela?', 'Porque o resultado de uma função pura depende apenas de seus argumentos, permitindo que a execução seja realizada em paralelo sem problemas de sincronização.', ['Porque elas dependem de um estado compartilhado.', 'Porque elas criam efeitos colaterais.', 'Porque o resultado de uma função pura depende apenas de seus argumentos, permitindo que a execução seja realizada em paralelo sem problemas de sincronização.', 'Porque elas são mais difíceis de testar.', 'Porque elas não podem ser usadas em funções de ordem superior.']).
pergunta_mestra('M7_Q4', 7, 'Qual é a principal vantagem de ''funções de ordem superior'' (higher-order functions) em relação à expressividade de uma linguagem?', 'Elas permitem a criação de abstrações de controle e a reusabilidade de código de forma mais concisa.', ['Elas tornam o código mais difícil de ler.', 'Elas permitem a criação de abstrações de controle e a reusabilidade de código de forma mais concisa.', 'Elas são usadas apenas para lidar com efeitos colaterais.', 'Elas limitam a programação a um único tipo de dados.', 'Elas não podem ser passadas como argumentos.']).
pergunta_mestra('M7_Q5', 7, 'Como o conceito de ''currying'' se relaciona com ''funções de ordem superior''?', 'Currying é uma aplicação de funções de ordem superior que permite a criação de novas funções com base em funções existentes com alguns argumentos fixos.', ['Currying não tem relação com funções de ordem superior.', 'Currying é um tipo de polimorfismo.', 'Currying é a prática de criar funções que aceitam todos os seus argumentos de uma vez.', 'Currying é um recurso exclusivo de linguagens imperativas.', 'Currying é uma aplicação de funções de ordem superior que permite a criação de novas funções com base em funções existentes com alguns argumentos fixos.']).
pergunta_mestra('M7_Q6', 7, 'O que a ''avaliação preguiçosa'' (lazy evaluation) permite em linguagens funcionais puras como Haskell?', 'Permite a construção de estruturas de dados infinitas e otimizações de desempenho, pois só avalia o que é necessário.', ['A avaliação de expressões imediatamente.', 'O uso de loops for.', 'A criação de efeitos colaterais incontroláveis.', 'A manipulação de estados mutáveis.', 'Permite a construção de estruturas de dados infinitas e otimizações de desempenho, pois só avalia o que é necessário.']).
pergunta_mestra('M7_Q7', 7, 'Em um programa funcional, como a ''recursão'' substitui os ''loops'' imperativos?', 'A recursão usa a chamada da própria função para iterar, sem a necessidade de modificar variáveis de estado.', ['A recursão utiliza variáveis mutáveis para controlar o loop.', 'A recursão é um tipo de comando.', 'A recursão é menos eficiente que loops.', 'A recursão usa a chamada da própria função para iterar, sem a necessidade de modificar variáveis de estado.', 'A recursão só é possível em linguagens impuras.']).
pergunta_mestra('M7_Q8', 7, 'Qual a principal diferença na abordagem entre o paradigma funcional e o paradigma imperativo?', 'Funcional foca na expressão e avaliação de funções, enquanto imperativo foca na sequência de comandos e manipulação de estado.', ['Funcional foca em como resolver um problema, imperativo em o que resolver.', 'Imperativo usa funções de ordem superior, funcional não.', 'Funcional foca na expressão e avaliação de funções, enquanto imperativo foca na sequência de comandos e manipulação de estado.', 'Não há diferença significativa.', 'Funcional é sempre compilado, imperativo sempre interpretado.']).
pergunta_mestra('M7_Q9', 7, 'O que é um ''fechamento'' (closure) no contexto funcional?', 'Uma função que ''captura'' variáveis de seu escopo circundante e pode acessá-las mesmo após o escopo não existir mais.', ['Um bloco de código que nunca pode ser executado.', 'Uma função que ''captura'' variáveis de seu escopo circundante e pode acessá-las mesmo após o escopo não existir mais.', 'Uma função que não tem argumentos.', 'Um tipo de dado imutável.', 'Uma estrutura de controle de loop.']).
pergunta_mestra('M7_Q10', 7, 'Como a ''imutabilidade'' ajuda a evitar ''referências soltas'' (dangling references) em linguagens funcionais?', 'Como os dados não são alterados, não há a necessidade de desalocação dinâmica, eliminando a fonte do problema.', ['A imutabilidade não tem relação com referências soltas.', 'A imutabilidade causa referências soltas.', 'Como os dados não são alterados, não há a necessidade de desalocação dinâmica, eliminando a fonte do problema.', 'A imutabilidade é um tipo de escopo dinâmico.', 'A imutabilidade só existe em linguagens com gerenciamento manual de memória.']).
pergunta_mestra('M7_Q11', 7, 'Qual o papel da ''semântica'' de uma linguagem (Missão 2) em um programa funcional?', 'A semântica define o significado das funções e expressões, garantindo a correção e previsibilidade do código.', ['A semântica não é importante no paradigma funcional.', 'A semântica lida apenas com a sintaxe.', 'A semântica verifica o formato do código.', 'A semântica define o significado das funções e expressões, garantindo a correção e previsibilidade do código.', 'A semântica é usada para traduzir o código.']).
pergunta_mestra('M7_Q12', 7, 'No paradigma funcional, o que o ''lambda calculus'' representa?', 'É a base teórica formal para a computação funcional e o estudo de funções.', ['É um tipo de dado.', 'É uma linguagem de programação de alto nível.', 'É a base teórica formal para a computação funcional e o estudo de funções.', 'É um sistema de tipos para linguagens funcionais.', 'É uma forma de polimorfismo.']).
pergunta_mestra('M7_Q13', 7, 'Qual a principal consequência da ''ausência de efeitos colaterais'' em um programa funcional?', 'O comportamento de uma função é totalmente previsível e o paralelismo é mais fácil de ser implementado.', ['Aumento da complexidade.', 'Dificuldade para testar o código.', 'Menor portabilidade.', 'O código se torna menos previsível.', 'O comportamento de uma função é totalmente previsível e o paralelismo é mais fácil de ser implementado.']).
pergunta_mestra('M7_Q14', 7, 'Em que sentido o ''polimorfismo paramétrico'' (Missão 3) se alinha com os princípios do paradigma funcional?', 'O polimorfismo paramétrico promove a criação de funções genéricas que não dependem do tipo de dado, promovendo a reutilização de código e a imutabilidade.', ['Polimorfismo paramétrico não se alinha com o paradigma funcional.', 'O polimorfismo paramétrico é um tipo de polimorfismo ad-hoc.', 'O polimorfismo paramétrico promove a criação de funções genéricas que não dependem do tipo de dado, promovendo a reutilização de código e a imutabilidade.', 'O polimorfismo paramétrico é exclusivo de linguagens imperativas.', 'O polimorfismo paramétrico é uma forma de coerção.']).
pergunta_mestra('M7_Q15', 7, 'Como o conceito de ''monads'' é utilizado em linguagens funcionais puras como Haskell?', 'Para lidar com efeitos colaterais como entrada/saída de forma controlada e segura.', ['Para criar efeitos colaterais de forma incontrolável.', 'Para lidar com efeitos colaterais como entrada/saída de forma controlada e segura.', 'Para criar variáveis mutáveis.', 'Para implementar loops for.', 'Monads são um tipo de dado primitivo.']).
pergunta_mestra('M7_Q16', 7, 'Por que a ''tipagem forte'' e ''estática'' é frequentemente encontrada em linguagens funcionais como Haskell?', 'Para garantir a correção do programa em tempo de compilação e evitar erros de tipo em tempo de execução.', ['Para permitir a conversão implícita de tipos.', 'Para diminuir a expressividade da linguagem.', 'Porque a tipagem dinâmica é mais segura.', 'Para garantir a correção do programa em tempo de compilação e evitar erros de tipo em tempo de execução.', 'Porque a tipagem estática não suporta polimorfismo.']).
pergunta_mestra('M7_Q17', 7, 'Em linguagens multiparadigmas como Python ou OCaml, qual a principal diferença na implementação do paradigma funcional em relação a linguagens puramente funcionais?', 'Elas permitem a combinação de funções e imutabilidade com comandos imperativos e estados mutáveis.', ['Elas não suportam funções de ordem superior.', 'Elas não têm funções puras.', 'Elas permitem a combinação de funções e imutabilidade com comandos imperativos e estados mutáveis.', 'Elas são puramente funcionais.', 'Elas não têm um sistema de tipos.']).
pergunta_mestra('M7_Q18', 7, 'O que é o conceito de ''composição de funções'' (function composition) e por que é importante no paradigma funcional?', 'É a prática de combinar funções menores para construir funções mais complexas, promovendo a modularidade e o reuso.', ['A prática de passar uma função como argumento para outra.', 'É um tipo de loop.', 'É o mesmo que sobrecarga de operadores.', 'É um erro de compilação.', 'É a prática de combinar funções menores para construir funções mais complexas, promovendo a modularidade e o reuso.']).
pergunta_mestra('M7_Q19', 7, 'Qual é a principal desvantagem da ''avaliação preguiçosa''?', 'A dificuldade em prever o momento exato da avaliação, o que pode levar a um desempenho inesperado e a maior consumo de memória.', ['Maior consumo de memória.', 'Maior dificuldade em paralelizar.', 'Não permite a construção de estruturas de dados infinitas.', 'Não é eficiente.', 'A dificuldade em prever o momento exato da avaliação, o que pode levar a um desempenho inesperado e a maior consumo de memória.']).
pergunta_mestra('M7_Q20', 7, 'No paradigma funcional, qual o principal objetivo dos ''sistemas de tipos''?', 'Garantir que as operações com funções e dados sejam seguras e consistentes em tempo de compilação.', ['Permitir o uso de variáveis mutáveis.', 'Garantir que as operações com funções e dados sejam seguras e consistentes em tempo de compilação.', 'Promover o uso de efeitos colaterais.', 'Diminuir a reusabilidade de código.', 'Impedir a criação de funções de ordem superior.']).

% --- Missão 8 ---
pergunta_mestra('M8_Q1', 8, 'Qual é a principal característica do paradigma de programação lógica?', 'Descrever o problema em termos de fatos e regras e deixar que o interpretador infira a solução.', ['Focar em como resolver um problema passo a passo.', 'Utilizar funções puras e imutabilidade.', 'Descrever o problema em termos de fatos e regras e deixar que o interpretador infira a solução.', 'Usar variáveis mutáveis e comandos.', 'Separar a interface gráfica da lógica do programa.']).
pergunta_mestra('M8_Q2', 8, 'A linguagem Prolog, principal exemplo de programação lógica, se baseia em qual área da matemática?', 'Lógica de predicados de primeira ordem.', ['Cálculo diferencial.', 'Álgebra linear.', 'Teoria dos grafos.', 'Lógica de predicados de primeira ordem.', 'Estatística.']).
pergunta_mestra('M8_Q3', 8, 'O que um ''programa lógico'' é composto?', 'De fatos, regras de inferência e perguntas sobre esses fatos e regras.', ['De uma sequência de comandos e atribuições.', 'De funções e listas.', 'De classes e objetos.', 'De eventos e handlers.']).
pergunta_mestra('M8_Q4', 8, 'O que é um ''fato'' em um programa lógico?', 'Uma proposição que é declarada como verdadeira.', ['Uma expressão que pode ser avaliada.', 'Uma proposição que é declarada como verdadeira.', 'Uma variável que pode ser modificada.', 'Um comando que altera o estado do programa.', 'Uma função que retorna um valor.']).
pergunta_mestra('M8_Q5', 8, 'Como o interpretador do paradigma lógico encontra a solução para uma pergunta?', 'Fazendo uma busca na base de conhecimento (fatos e regras) para unificar a pergunta com fatos ou regras.', ['Executando uma sequência de comandos.', 'Usando um algoritmo de ordenação.', 'Modificando o valor de variáveis.', 'Aplicando funções.', 'Fazendo uma busca na base de conhecimento (fatos e regras) para unificar a pergunta com fatos ou regras.']).
pergunta_mestra('M8_Q6', 8, 'O que é uma ''regra de inferência''?', 'Uma proposição que define como deduzir novos fatos a partir de fatos existentes.', ['Um fato que sempre é verdadeiro.', 'Um comando de atribuição.', 'Uma proposição que define como deduzir novos fatos a partir de fatos existentes.', 'Uma função que retorna um valor.', 'Uma variável global.']).
pergunta_mestra('M8_Q7', 8, 'O que ''unificação'' significa no contexto do paradigma lógico?', 'O processo de casar uma pergunta com um fato ou regra da base de conhecimento.', ['Um erro de compilação.', 'A capacidade de um objeto ter múltiplos tipos.', 'A prática de combinar funções.', 'O processo de casar uma pergunta com um fato ou regra da base de conhecimento.', 'O uso de loops para iteração.']).
pergunta_mestra('M8_Q8', 8, 'Por que o paradigma lógico é classificado como ''declarativo''?', 'Porque o programador especifica o que se quer como resultado, sem se preocupar com os detalhes de implementação.', ['Porque o programador especifica como resolver o problema.', 'Porque o foco está na modificação do estado do programa.', 'Porque o programador especifica o que se quer como resultado, sem se preocupar com os detalhes de implementação.', 'Porque ele é baseado em funções puras.', 'Porque ele é um tipo de programação estruturada.']).
pergunta_mestra('M8_Q9', 8, 'Em qual área da informática o paradigma lógico é amplamente utilizado?', 'Inteligência artificial e sistemas especialistas.', ['Desenvolvimento web de front-end.', 'Inteligência artificial e sistemas especialistas.', 'Desenvolvimento de sistemas operacionais.', 'Programação de jogos.', 'Banco de dados relacionais.']).
pergunta_mestra('M8_Q10', 8, 'Qual a principal diferença entre um programa lógico e um programa imperativo?', 'Programas lógicos se concentram em ''o que'' e programas imperativos em ''como''.', ['Programas lógicos usam variáveis mutáveis.', 'Programas lógicos são sempre compilados.', 'Programas lógicos se concentram em ''o que'' e programas imperativos em ''como''.', 'Não há diferença.', 'Programas lógicos não usam funções.']).
pergunta_mestra('M8_Q11', 8, 'O que a ''recursão'' representa no paradigma lógico?', 'É a principal forma de iteração e de processar estruturas de dados.', ['É a única forma de criar efeitos colaterais.', 'É um tipo de comando.', 'É uma operação de atribuição.', 'É a forma de unificar fatos.', 'É a principal forma de iteração e de processar estruturas de dados.']).
pergunta_mestra('M8_Q12', 8, 'Qual é a principal vantagem do paradigma lógico para resolver problemas?', 'A possibilidade de expressar o problema de forma concisa e próxima da linguagem humana e formal.', ['Facilidade em lidar com tarefas de entrada/saída.', 'Maior eficiência em cálculos numéricos.', 'A possibilidade de expressar o problema de forma concisa e próxima da linguagem humana e formal.', 'Não tem vantagens.', 'A sintaxe é mais simples que a de outras linguagens.']).
pergunta_mestra('M8_Q13', 8, 'No contexto do paradigma lógico, o que é ''backtracking''?', 'Um mecanismo que permite ao interpretador explorar caminhos alternativos de busca quando uma tentativa falha.', ['O processo de unificar um fato.', 'Um mecanismo que permite ao interpretador explorar caminhos alternativos de busca quando uma tentativa falha.', 'Um erro de sintaxe.', 'Um tipo de dado.', 'Uma função de ordem superior.']).
pergunta_mestra('M8_Q14', 8, 'Prolog lida com objetos e relações entre eles. O que ''objetos'' significam nesse contexto?', 'São ''coisas'' sobre as quais o programa pode raciocinar, mas não têm métodos ou herança.', ['São instâncias de classes com métodos.', 'São elementos mutáveis.', 'São apenas números.', 'São ''coisas'' sobre as quais o programa pode raciocinar, mas não têm métodos ou herança.', 'São constantes.']).
pergunta_mestra('M8_Q15', 8, 'Qual a principal desvantagem do paradigma lógico?', 'Ineficiência e dificuldade de lidar com cálculos matemáticos complexos.', ['Dificuldade em expressar problemas complexos.', 'Baixa portabilidade.', 'Ineficiência e dificuldade de lidar com cálculos matemáticos complexos.', 'A sintaxe é muito verbosa.', 'Não suporta recursão.']).
pergunta_mestra('M8_Q16', 8, 'Qual é a relação entre o paradigma lógico e o paradigma imperativo no que diz respeito ao estado do programa?', 'O paradigma lógico não possui estado mutável, enquanto o imperativo é focado na sua modificação.', ['O paradigma lógico não possui estado mutável, enquanto o imperativo é focado na sua modificação.', 'Ambos os paradigmas são focados em modificar o estado.', 'O paradigma lógico utiliza variáveis mutáveis.', 'O estado é um conceito irrelevante para o paradigma lógico.', 'O paradigma lógico utiliza o estado para controlar a execução.']).
pergunta_mestra('M8_Q17', 8, 'Em um programa Prolog, o que representa uma ''pergunta'' (query)?', 'Uma solicitação ao interpretador para tentar provar se uma proposição é verdadeira com base na base de conhecimento.', ['Uma atribuição de valor a uma variável.', 'A definição de um novo fato.', 'Uma regra de inferência.', 'A declaração de uma função.', 'Uma solicitação ao interpretador para tentar provar se uma proposição é verdadeira com base na base de conhecimento.']).
pergunta_mestra('M8_Q18', 8, 'Como o paradigma lógico lida com a ''transparência referencial''?', 'Suporta a transparência referencial porque a avaliação de uma consulta não causa efeitos colaterais.', ['Não a suporta, porque o estado do programa é mutável.', 'Suporta a transparência referencial porque a avaliação de uma consulta não causa efeitos colaterais.', 'A transparência referencial é um conceito irrelevante.', 'A transparência referencial é o que causa os efeitos colaterais.', 'Só suporta a transparência referencial em funções puras.']).
pergunta_mestra('M8_Q19', 8, 'Qual é a principal diferença entre um sistema de ''fato'' e um sistema de ''regra''?', 'Fatos são proposições concretas e conhecidas, enquanto regras são proposições que definem como deduzir novos fatos.', ['Fatos são proposições que são provadas falsas.', 'Regras não podem ser usadas para deduzir novos fatos.', 'Fatos dependem de outras proposições.', 'Fatos são proposições concretas e conhecidas, enquanto regras são proposições que definem como deduzir novos fatos.', 'Não há diferença entre eles.']).
pergunta_mestra('M8_Q20', 8, 'A linguagem Prolog é considerada uma linguagem de que geração?', 'Quinta geração, voltada para inteligência artificial.', ['Quinta geração, voltada para inteligência artificial.', 'Primeira geração, voltada para cálculos numéricos.', 'Terceira geração, procedural.', 'Segunda geração, de montagem.', 'Quarta geração, aplicativa.']).

pergunta_mestra('M9_Q1', 9, 'Qual a relação entre a ''programação em lógica'' (Missão 8) e a ''programação declarativa'' (Missão 2)?', 'O paradigma lógico é um subtipo do paradigma declarativo, pois o programador especifica o que se quer como resultado, não o como.', ['O paradigma lógico é um subtipo do paradigma declarativo, pois o programador especifica o que se quer como resultado, não o como.', 'O paradigma lógico é um paradigma puramente imperativo.', 'O paradigma declarativo se baseia em fatos e regras.', 'Não há relação entre eles.', 'O paradigma lógico é a base do paradigma imperativo.']).
pergunta_mestra('M9_Q2', 9, 'Como o conceito de ''unificação'' (Missão 8) em Prolog é mais eficiente do que a ''busca'' simples em uma base de dados?', 'A unificação permite casar perguntas com fatos ou regras, o que é uma forma poderosa e flexível de recuperação de informação, indo além de uma busca por valores.', ['A unificação é uma operação de atribuição.', 'A unificação não é um conceito importante em Prolog.', 'A unificação permite casar perguntas com fatos ou regras, o que é uma forma poderosa e flexível de recuperação de informação, indo além de uma busca por valores.', 'A unificação é um tipo de comando.', 'A unificação só funciona com números inteiros.']).
pergunta_mestra('M9_Q3', 9, 'Qual é a principal diferença no uso da ''recursão'' (Missão 6) entre o paradigma funcional e o paradigma lógico?', 'No funcional, a recursão é usada para aplicar funções a uma estrutura de dados. No lógico, é usada para percorrer a base de conhecimento durante o processo de prova.', ['O paradigma funcional usa recursão para modificar o estado, o lógico não.', 'No funcional, a recursão é usada para aplicar funções a uma estrutura de dados. No lógico, é usada para percorrer a base de conhecimento durante o processo de prova.', 'Não há diferença no uso.', 'O paradigma funcional usa a recursão de cauda, o lógico não.', 'A recursão é um conceito irrelevante para ambos.']).
pergunta_mestra('M9_Q4', 9, 'Em relação à ''transparência referencial'' (Missão 6), como o paradigma lógico se comporta em comparação ao imperativo (Missão 4)?', 'O paradigma lógico suporta a transparência referencial (sem efeitos colaterais), enquanto o imperativo é focado em modificar o estado, quebrando a transparência.', ['O paradigma lógico não tem transparência referencial.', 'O paradigma imperativo suporta a transparência referencial.', 'Ambos são transparentes referencialmente.', 'O paradigma lógico suporta a transparência referencial (sem efeitos colaterais), enquanto o imperativo é focado em modificar o estado, quebrando a transparência.', 'Não há diferença entre eles.']).
pergunta_mestra('M9_Q5', 9, 'Qual é a diferença na abordagem para resolver um problema entre o ''paradigma imperativo'' (Missão 4) e o ''paradigma lógico'' (Missão 8)?', 'O imperativo foca em uma sequência de comandos, o lógico em fatos e regras.', ['O imperativo foca em uma sequência de comandos, o lógico em fatos e regras.', 'O imperativo usa recursão e o lógico não.', 'O imperativo é um paradigma declarativo.', 'O lógico usa variáveis mutáveis, o imperativo não.', 'Não há diferença significativa.']).
pergunta_mestra('M9_Q6', 9, 'Como o conceito de ''fato'' e ''regra'' do paradigma lógico se relaciona com os ''sistemas de tipos'' (Missão 3)?', 'A definição de fatos e regras em um programa lógico pode ser vista como uma forma de especificar a ''tipagem'' ou ''relações'' que são válidas no sistema.', ['Fatos e regras são tipos de dados.', 'Não há relação, são conceitos de paradigmas diferentes.', 'A definição de fatos e regras em um programa lógico pode ser vista como uma forma de especificar a ''tipagem'' ou ''relações'' que são válidas no sistema.', 'Sistemas de tipos são usados apenas em linguagens imperativas.', 'Fatos e regras são exclusivos de linguagens fracamente tipadas.']).
pergunta_mestra('M9_Q7', 9, 'Qual a relação entre ''backtracking'' (Missão 8) e a ''busca por soluções'' no paradigma lógico?', 'Backtracking é o mecanismo automático que permite ao interpretador ''voltar'' e tentar caminhos alternativos na árvore de busca para encontrar soluções.', ['Backtracking é a mesma coisa que recursão de cauda.', 'Backtracking é o mecanismo automático que permite ao interpretador ''voltar'' e tentar caminhos alternativos na árvore de busca para encontrar soluções.', 'Backtracking não é usado para encontrar soluções.', 'Backtracking é um tipo de comando.', 'Backtracking é um erro de compilação.']).
pergunta_mestra('M9_Q8', 9, 'Em relação aos ''sistemas de tipos'' (Missão 3), por que o paradigma lógico não necessita de um sistema de tipos estáticos rigoroso?', 'Porque a ''unificação'' e a ''prova de teoremas'' intrínsecas ao paradigma já atuam como uma forma de ''verificação'' de consistência.', ['Porque ele usa variáveis mutáveis.', 'Porque ele é um tipo de programação funcional.', 'Porque ele é um paradigma imperativo.', 'Porque ele não lida com dados.', 'Porque a ''unificação'' e a ''prova de teoremas'' intrínsecas ao paradigma já atuam como uma forma de ''verificação'' de consistência.']).
pergunta_mestra('M9_Q9', 9, 'Como o ''monomorfismo'' (Missão 3) e o ''polimorfismo'' (Missão 3) se aplicam ao paradigma lógico?', 'O paradigma lógico utiliza um tipo de polimorfismo em que as variáveis podem assumir valores de diferentes tipos para satisfazer a unificação.', ['O paradigma lógico não tem polimorfismo.', 'O polimorfismo em lógica é o mesmo que em OO.', 'O paradigma lógico utiliza um tipo de polimorfismo em que as variáveis podem assumir valores de diferentes tipos para satisfazer a unificação.', 'O paradigma lógico é puramente monomórfico.', 'O paradigma lógico usa polimorfismo de sobrecarga.']).
pergunta_mestra('M9_Q10', 9, 'Em um programa lógico, qual a principal diferença entre ''fato'' e ''regra''?', 'Fato é uma proposição verdadeira conhecida, regra é uma forma de deduzir novos fatos.', ['Não há diferença.', 'Regras são sempre mais importantes que fatos.', 'Fatos são dinâmicos e regras são estáticas.', 'Fatos têm efeitos colaterais, regras não.', 'Fato é uma proposição verdadeira conhecida, regra é uma forma de deduzir novos fatos.']).
pergunta_mestra('M9_Q11', 9, 'Como o ''escopo dinâmico'' (Missão 4) poderia ser comparado ao ''backtracking'' (Missão 8)?', 'O escopo dinâmico se baseia no fluxo de execução, assim como o backtracking explora o fluxo de busca de soluções.', ['Backtracking é um tipo de escopo dinâmico.', 'O escopo dinâmico não tem relação com a busca.', 'Ambos são conceitos de programação funcional.', 'O escopo dinâmico se baseia no fluxo de execução, assim como o backtracking explora o fluxo de busca de soluções.', 'Não há nenhuma relação entre os dois.']).
pergunta_mestra('M9_Q12', 9, 'Qual a principal vantagem do paradigma lógico para ''inteligência artificial'' (Missão 8) em comparação com outros paradigmas?', 'Permite a representação de conhecimento e raciocínio lógico de forma declarativa, sendo ideal para sistemas especialistas e de prova de teoremas.', ['O paradigma lógico é mais rápido.', 'Ele é uma forma de programação imperativa.', 'Ele é menos expressivo.', 'Ele é puramente funcional.', 'Permite a representação de conhecimento e raciocínio lógico de forma declarativa, sendo ideal para sistemas especialistas e de prova de teoremas.']).
pergunta_mestra('M9_Q13', 9, 'Por que o paradigma lógico é menos eficiente para ''cálculos numéricos'' (Missão 8) que o paradigma imperativo?', 'Porque sua abordagem de prova de teoremas não é otimizada para operações aritméticas, que são mais diretas em uma máquina de von Neumann.', ['Ele é mais rápido.', 'Porque sua abordagem de prova de teoremas não é otimizada para operações aritméticas, que são mais diretas em uma máquina de von Neumann.', 'Porque ele não pode usar funções.', 'Porque ele usa variáveis mutáveis.', 'Não é menos eficiente.']).
pergunta_mestra('M9_Q14', 9, 'Qual a relação entre os conceitos de ''comandos'' (Missão 4) e ''regras de inferência'' (Missão 8)?', 'Comandos alteram o estado do programa, enquanto regras são usadas para deduzir novos fatos sem alterar o estado.', ['Comandos e regras são a mesma coisa.', 'Comandos são usados para descrever o que fazer, regras para como fazer.', 'Comandos alteram o estado do programa, enquanto regras são usadas para deduzir novos fatos sem alterar o estado.', 'Regras são usados para a sintaxe, comandos para a semântica.', 'Comandos só existem em linguagens lógicas.']).
pergunta_mestra('M9_Q15', 9, 'Como o conceito de ''valores de primeira classe'' (Missão 3) se aplica ao paradigma lógico?', 'O paradigma lógico foca em fatos e regras, e não em valores de primeira classe como funções, que são centrais no paradigma funcional.', ['Valores de primeira classe não se aplicam ao paradigma lógico.', 'Valores de primeira classe são sempre mutáveis.', 'O paradigma lógico foca em fatos e regras, e não em valores de primeira classe como funções, que são centrais no paradigma funcional.', 'Valores de primeira classe são sempre números.', 'Valores de primeira classe são exclusivos de linguagens imperativas.']).
pergunta_mestra('M9_Q16', 9, 'Qual a principal desvantagem do paradigma lógico em termos de ''legibilidade''?', 'A forma de expressar lógica e resolução de problemas pode ser não-intuitiva para programadores acostumados com o modelo imperativo.', ['A legibilidade é sempre alta.', 'Ele usa muitas variáveis mutáveis.', 'Ele é muito parecido com a linguagem humana.', 'Ele não usa recursão.', 'A forma de expressar lógica e resolução de problemas pode ser não-intuitiva para programadores acostumados com o modelo imperativo.']).
pergunta_mestra('M9_Q17', 9, 'O que a ''semântica'' (Missão 2) de uma linguagem lógica representa?', 'O significado das relações e fatos, e como o sistema infere novas conclusões a partir deles.', ['A forma como o código é escrito.', 'O significado das relações e fatos, e como o sistema infere novas conclusões a partir deles.', 'O processo de otimização do código.', 'A tradução para código de máquina.', 'A alocação de memória.']).
pergunta_mestra('M9_Q18', 9, 'Qual a relação entre a ''arquitetura de von Neumann'' (Missão 4) e o paradigma lógico (Missão 8)?', 'Não há uma relação direta, pois o paradigma lógico não é um modelo de execução sequencial baseado em estado mutável, como é o caso das linguagens imperativas.', ['O paradigma lógico é baseado na arquitetura de von Neumann.', 'O paradigma lógico é o único paradigma adequado para a arquitetura.', 'Não há relação, pois o paradigma lógico é um modelo de computação abstrato, não focado em estado e comandos.', 'Não há uma relação direta, pois o paradigma lógico não é um modelo de execução sequencial baseado em estado mutável, como é o caso das linguagens imperativas.', 'O paradigma lógico usa o mesmo modelo de memória que o paradigma imperativo.']).
pergunta_mestra('M9_Q19', 9, 'O que o ''backtracking'' no paradigma lógico tem em comum com o ''fluxo de controle'' no paradigma imperativo?', 'Ambos são mecanismos para controlar o fluxo de execução, mas o backtracking é para a busca de soluções, enquanto o fluxo de controle imperativo é para a sequência de comandos.', ['Ambos são formas de programação funcional.', 'Ambos se baseiam em comandos de atribuição.', 'Ambos são mecanismos para controlar o fluxo de execução, mas o backtracking é para a busca de soluções, enquanto o fluxo de controle imperativo é para a sequência de comandos.', 'Ambos são usados para depurar o código.', 'Não há nada em comum.']).
pergunta_mestra('M9_Q20', 9, 'Qual a principal diferença no tratamento de ''erros de tipo'' entre uma linguagem com tipagem estática (Missão 3) e uma linguagem lógica como Prolog?', 'A linguagem com tipagem estática detecta o erro em tempo de compilação, enquanto em Prolog a ''unificação'' falha se a pergunta é inconsistente com os fatos.', ['A linguagem com tipagem estática detecta o erro em tempo de compilação, enquanto em Prolog a ''unificação'' falha se a pergunta é inconsistente com os fatos.', 'Ambos detectam erros de tipo em tempo de execução.', 'Não há diferença.', 'Prolog não tem erros de tipo.', 'A linguagem com tipagem estática não tem erros.']).