id_questao;missao;pergunta;alternativa_certa;texto_alternativa_a;texto_alternativa_b;texto_alternativa_c;texto_alternativa_d;texto_alternativa_e;texto_alternativa_certa
M1_Q1;1;"Qual das seguintes não é uma característica de uma linguagem de programação conforme definido no documento?";b;"Expressividade";"Portabilidade";"Universalidade";"Simplicidade";"Implementável";"Portabilidade"
M1_Q2;1;"O que a característica de 'Universalidade' de uma linguagem de programação implica?";c;"Que ela deve ser fácil de aprender.";"Que ela pode resolver apenas problemas matemáticos.";"Que ela pode resolver qualquer problema que um computador seja capaz de resolver.";"Que ela deve ser usada por todos os programadores.";"Que ela só pode ser usada em máquinas de alto desempenho.";"Que ela pode resolver qualquer problema que um computador seja capaz de resolver."
M1_Q3;1;"De acordo com o documento, qual a principal diferença entre uma linguagem de programação e uma linguagem de consulta a banco de dados (query language)?";a;"A linguagem de programação precisa dar suporte a recursão, iteração ou desvios.";"A linguagem de programação é sempre mais antiga.";"A linguagem de programação é de alto nível.";"A linguagem de consulta é mais popular.";"A linguagem de programação é usada apenas para fins comerciais.";"A linguagem de programação precisa dar suporte a recursão, iteração ou desvios."
M1_Q4;1;"O que é uma linguagem de programação de baixo nível de acordo com o texto?";a;"Uma linguagem com instruções que refletem de forma mais direta as operações em nível de máquina.";"Uma linguagem com sintaxe complexa e difícil de usar.";"Uma linguagem com alta portabilidade.";"Uma linguagem que é mais lenta e consome mais recursos.";"Uma linguagem projetada para aplicações de IA.";"Uma linguagem com instruções que refletem de forma mais direta as operações em nível de máquina."
M1_Q5;1;"Qual é uma das principais desvantagens de usar uma linguagem de programação de baixo nível segundo o documento?";b;"É difícil de traduzir para linguagem de máquina.";"Tem pouca portabilidade.";"Consome menos recursos do sistema.";"É mais simples de programar.";"É a mais eficiente em termos de tempo.";"Tem pouca portabilidade."
M1_Q6;1;"Qual linguagem de programação é citada como exemplo de uma LP de baixo nível?";d;"Python";"Java";"C++";"Assembly";"Pascal";"Assembly"
M1_Q7;1;"Qual das seguintes linguagens é descrita como sendo a primeira a introduzir conceitos de orientação a objetos (OO) como classe e herança?";d;"Pascal";"Fortran";"C";"Simula";"Lisp";"Simula"
M1_Q8;1;"Qual LP desenvolvida pela IBM na década de 1950 foi voltada para computação numérica e científica e introduziu o conceito de arrays e procedimentos com parâmetros?";e;"Algol-60";"Pascal";"C";"Simula";"Fortran";"Fortran"
M1_Q9;1;"Qual LP descrita no documento como a primeira puramente orientada a objetos e dinamicamente tipada e oferece suporte a reflexão?";d;"Java";"C";"C++";"Smalltalk";"Simula";"Smalltalk"
M1_Q10;1;"O documento menciona que a programação estruturada começou a ser introduzida com qual linguagem?";a;"Algol-60";"Fortran";"Simula";"C";"Pascal";"Algol-60"
M1_Q11;1;"Qual linguagem foi fortemente inspirada em Algol e se tornou a principal para ensino de programação por sua simplicidade e suporte a programação estruturada?";a;"Pascal";"C";"Simula";"Fortran";"Lisp";"Pascal"
M1_Q12;1;"Qual linguagem projetada para sistemas de informação comerciais é descrita como verborrágica e ainda hoje é ativa?";c;"Java";"Pascal";"Cobol";"Fortran";"Python";"Cobol"
M1_Q13;1;"Qual linguagem de grande importância histórica foi utilizada para reimplementar o sistema operacional Unix?";a;"C";"Java";"Python";"Fortran";"Lisp";"C"
M1_Q14;1;"A que estilo de programação a linguagem Lisp de 1958 é precursora?";b;"Programação orientada a objetos";"Programação funcional";"Programação imperativa";"Programação estruturada";"Programação lógica";"Programação funcional"
M1_Q15;1;"O que a linguagem Algol-60 introduziu para melhorar a legibilidade e o tempo de desenvolvimento de programas?";c;"O uso de desvios incondicionais.";"O uso de linguagens de baixo nível.";"O uso de blocos delimitados de código e escopo.";"A introdução da programação puramente orientada a objetos.";"A ênfase na computação numérica.";"O uso de blocos delimitados de código e escopo."
M1_Q16;1;"Qual é o significado da sigla COBOL?";b;"Common Object-Based Online Language";"Common Business Oriented Language";"Common Business and Office Language";"Computer Business Oriented Language";"Common Block-Oriented Language";"Common Business Oriented Language"
M1_Q17;1;"A qual das seguintes LP o documento se refere como 'Linguagem de Programação em Lógica'?";d;"Lisp";"Java";"Python";"Prolog";"Smalltalk";"Prolog"
M1_Q18;1;"Qual das seguintes características de uma LP está relacionada à execução em um tempo aceitável para os propósitos de uso da linguagem?";a;"Eficiência";"Simplicidade";"Universalidade";"Expressividade";"Implementável";"Eficiência"
M1_Q19;1;"Segundo o documento, até os anos 50, quais eram os principais usos dos computadores?";c;"Aplicações de IA.";"Sistemas de informação comerciais.";"Cálculos numéricos.";"Edição de texto.";"Jogos.";"Cálculos numéricos."
M1_Q20;1;"Qual das opções abaixo não é uma das características desejáveis em uma LP conforme listado no slide 'Características' e 'Simplicidade'?";e;"Expressividade.";"Simplicidade.";"Suporte a abstração.";"Implementável.";"Maior poder expressivo que dificulta o aprendizado.";"Maior poder expressivo que dificulta o aprendizado."
M2_Q1;2;"O que é uma linguagem de baixo nível segundo o documento?";c;"Uma linguagem que não precisa de compilador.";"Uma linguagem com sintaxe complexa e difícil de usar.";"Uma linguagem cujas instruções são escritas utilizando as instruções do microprocessador.";"Uma linguagem que suporta vários paradigmas.";"Uma linguagem que não é universal.";"Uma linguagem cujas instruções são escritas utilizando as instruções do microprocessador."
M2_Q2;2;"Qual das seguintes é uma característica das linguagens de alto nível?";a;"Sintaxe mais estruturada e independente da arquitetura do computador.";"Baixa portabilidade.";"Dificuldade de implementação.";"Instruções que refletem diretamente as operações da máquina.";"Pouca expressividade.";"Sintaxe mais estruturada e independente da arquitetura do computador."
M2_Q3;2;"Qual o principal problema das linguagens compiladas mencionado no texto?";b;"Baixa eficiência.";"Problemas com portabilidade e depuração.";"Lentidão na execução.";"Maior consumo de memória.";"Sintaxe muito complexa.";"Problemas com portabilidade e depuração."
M2_Q4;2;"De acordo com o documento, qual o papel de um compilador?";d;"Executar o programa diretamente.";"Converter a linguagem de máquina em código fonte.";"Apenas verificar erros de sintaxe.";"Traduzir um programa de uma linguagem para outra semanticamente equivalente.";"Tornar o programa mais eficiente.";"Traduzir um programa de uma linguagem para outra semanticamente equivalente."
M2_Q5;2;"Qual das seguintes é uma vantagem das linguagens interpretadas?";b;"Maior eficiência.";"Flexibilidade, portabilidade e facilidade para prototipação.";"Menor consumo de memória.";"Tradução direta para código de máquina.";"Sintaxe mais simples.";"Flexibilidade, portabilidade e facilidade para prototipação."
M2_Q6;2;"Qual é a primeira fase da compilação de acordo com o exemplo?";e;"Tradução para linguagem de montagem.";"Análise Semântica.";"Análise Sintática.";"Tradução para linguagem intermediária.";"Análise Léxica.";"Análise Léxica."
M2_Q7;2;"O que é 'semântica' de um programa?";a;"O significado do programa.";"O formato do programa.";"A sua capacidade de ser compilado.";"O uso de variáveis mutáveis.";"O número de linhas de código.";"O significado do programa."
M2_Q8;2;"Qual das linguagens a seguir é citada como um exemplo de LP compilada estaticamente?";e;"Python";"Java";"PHP";"C#";"C++";"C++"
M2_Q9;2;"De acordo com o diagrama de paradigmas, quais são as duas grandes categorias de paradigmas?";c;"Estruturado e Orientado a objetos.";"Funcional e Lógico.";"Imperativo e Declarativo.";"Concorrente e Estruturado.";"Imperativo e Funcional.";"Imperativo e Declarativo."
M2_Q10;2;"Qual dos paradigmas listados a seguir é uma subcategoria do paradigma Imperativo?";a;"Estruturado.";"Lógico.";"Funcional.";"Concorrente.";"Orientado a objetos.";"Estruturado."
M2_Q11;2;"Qual das linguagens é um exemplo de paradigma puramente lógico?";e;"Lisp";"C++";"Java";"Python";"Prolog";"Prolog"
M2_Q12;2;"Que paradigma de LP é definido por 'objeto, mensagem'?";b;"Paradigma funcional.";"Paradigma orientado a objetos.";"Paradigma lógico.";"Paradigma concorrente.";"Paradigma imperativo.";"Paradigma orientado a objetos."
M2_Q13;2;"Qual é a principal desvantagem de linguagens interpretadas?";c;"Problemas com portabilidade.";"Dificuldade para prototipação.";"Ineficiência e maior consumo de memória.";"Sintaxe complexa.";"Falta de flexibilidade.";"Ineficiência e maior consumo de memória."
M2_Q14;2;"Qual das linguagens a seguir é um exemplo de LP interpretada?";a;"Java.";"C.";"Fortran.";"Pascal.";"Assembly.";"Java."
M2_Q15;2;"A qual fase da compilação se refere a transformação de caracteres em tokens?";d;"Análise sintática.";"Análise semântica.";"Tradução para linguagem de montagem.";"Análise léxica.";"Tradução para linguagem intermediária.";"Análise léxica."
M2_Q16;2;"De acordo com o documento, o que é a sintaxe de um programa?";b;"O significado do programa.";"O formato do programa e como suas construções devem ser arranjadas.";"A sua eficiência.";"A sua capacidade de ser interpretado.";"A sua universalidade.";"O formato do programa e como suas construções devem ser arranjadas."
M2_Q17;2;"Qual é a definição do paradigma funcional?";e;"Relação, dedução.";"Estado, atribuição, sequência.";"Objeto, mensagem.";"Processo, comunicação.";"Função, aplicação, avaliação.";"Função, aplicação, avaliação."
M2_Q18;2;"Um programa sintaticamente correto é sempre semanticamente correto?";d;"Sim, sempre.";"Sim, se for compilado.";"Sim, se for interpretado.";"Não, pois podem ocorrer erros de significado.";"Sim, desde que não tenha erros de digitação.";"Não, pois podem ocorrer erros de significado."
M2_Q19;2;"Qual das seguintes é uma forma de apresentar a semântica de uma linguagem?";c;"Sintaxe de Backus Naur (BNF).";"Fase de análise léxica.";"Semântica Axiomática.";"Análise sintática.";"Fase de tradução.";"Semântica Axiomática."
M2_Q20;2;"Qual das linguagens a seguir é classificada como multiparadigma por combinar funcional e OO?";d;"Java";"C++";"Ada";"Ocaml";"Prolog";"Ocaml"
M3_Q1;3;"O que são valores de 'primeira classe' em uma LP?";b;"Valores que não podem ser passados como argumento.";"Valores que não possuem restrições para seu uso como argumentos ou retorno de funções.";"Valores que são sempre do tipo inteiro.";"Valores que são sempre mutáveis.";"Valores que só existem em tempo de compilação.";"Valores que não possuem restrições para seu uso como argumentos ou retorno de funções."
M3_Q2;3;"Em linguagens como C, strings e arrays são exemplos de valores de qual classe?";e;"Primeira classe";"Terceira classe";"Sem classe";"Classe indefinida";"Segunda classe";"Segunda classe"
M3_Q3;3;"Qual o principal objetivo dos 'Sistemas de Tipos' em LPs?";a;"Determinar a qual tipo os valores e expressões pertencem em tempo de execução.";"Aumentar a complexidade do código.";"Diminuir a expressividade da linguagem.";"Acelerar a tradução de código para linguagem de máquina.";"Permitir o uso de polimorfismo ad-hoc.";"Determinar a qual tipo os valores e expressões pertencem em tempo de execução."
M3_Q4;3;"Qual é a principal desvantagem dos sistemas de tipo mais antigos, onde toda variável e parâmetro precisava de uma declaração com tipo específico?";d;"Maior flexibilidade.";"Pouca segurança de tipo.";"Alto desempenho.";"Pouca reusabilidade de código e programação engessada.";"Sintaxe simples.";"Pouca reusabilidade de código e programação engessada."
M3_Q5;3;"O que é monomorfismo?";c;"Quando uma entidade pode ter vários tipos associados.";"Quando um programa é semanticamente incorreto.";"Quando toda entidade tem um único tipo específico associado.";"Quando uma função retorna outra função.";"Quando uma linguagem é fracamente tipada.";"Quando toda entidade tem um único tipo específico associado."
M3_Q6;3;"Qual é o problema do monomorfismo na construção de programas?";b;"Aumenta a segurança de tipo.";"Diminui a flexibilidade na construção de componentes reusáveis.";"Acelera o tempo de compilação.";"Aumenta a expressividade.";"Permite o uso de polimorfismo.";"Diminui a flexibilidade na construção de componentes reusáveis."
M3_Q7;3;"O que é polimorfismo?";a;"Abstrações que operam de maneira uniforme sobre valores de tipos diferentes.";"Entidades que só podem ter um tipo específico.";"Linguagens que não têm verificação de tipos.";"Programas que não são compiláveis.";"Valores de segunda classe.";"Abstrações que operam de maneira uniforme sobre valores de tipos diferentes."
M3_Q8;3;"De acordo com a classificação do polimorfismo, qual tipo é dividido em 'Sobrecarga' e 'Coerção'?";e;"Polimorfismo Universal.";"Polimorfismo Paramétrico.";"Polimorfismo de Inclusão.";"Polimorfismo de Herança.";"Polimorfismo Ad-hoc.";"Polimorfismo Ad-hoc."
M3_Q9;3;"O que caracteriza o polimorfismo por sobrecarga?";b;"Um identificador aplica-se a uma única operação.";"Um identificador se aplica a mais de uma operação.";"O tipo de uma variável pode ser alterado durante a execução.";"A linguagem não tem verificação de tipos.";"Uma função retorna uma lista.";"Um identificador se aplica a mais de uma operação."
M3_Q10;3;"Qual é a principal característica da sobrecarga de operadores?";a;"O comportamento é alterado de acordo com os tipos dos operandos.";"O número de operandos é fixo.";"O operador é ignorado.";"A ordem dos operandos não importa.";"O resultado é sempre um inteiro.";"O comportamento é alterado de acordo com os tipos dos operandos."
M3_Q11;3;"O que é a coerção em polimorfismo?";d;"A capacidade de um objeto ter múltiplos tipos.";"Um mecanismo que permite a reusabilidade de código.";"Quando a função é passada como argumento.";"Uma conversão implícita de tipo que pode ocorrer para evitar erros de tipo.";"Um erro de tipo que o compilador não detecta.";"Uma conversão implícita de tipo que pode ocorrer para evitar erros de tipo."
M3_Q12;3;"O que é polimorfismo universal?";c;"Abstrações que atuam em um número finito de tipos.";"Quando a coerção não é permitida.";"Abstrações que atuam sobre um número infinito de tipos.";"Quando a sobrecarga de operadores é desativada.";"O tipo de uma variável não pode ser alterado.";"Abstrações que atuam sobre um número infinito de tipos."
M3_Q13;3;"Qual das linguagens a seguir é usada como exemplo de polimorfismo de inclusão no documento?";a;"Java.";"Python.";"Haskell.";"C.";"Lisp.";"Java."
M3_Q14;3;"O polimorfismo de inclusão caracteriza uma relação entre o que?";b;"Tipos e classes.";"Implementações e reuso de código.";"Funções e variáveis.";"Compiladores e interpretadores.";"Sintaxe e semântica.";"Implementações e reuso de código."
M3_Q15;3;"O que é polimorfismo paramétrico?";d;"Uma forma de coerção.";"Um tipo de herança.";"Uma forma de sobrecarga.";"Permite que uma abstração seja escrita de forma genérica para atuar sobre diferentes tipos.";"A capacidade de um tipo ser de primeira classe.";"Permite que uma abstração seja escrita de forma genérica para atuar sobre diferentes tipos."
M3_Q16;3;"Qual é o tipo de polimorfismo implementado em Java através de 'Generics'?";e;"Polimorfismo ad-hoc.";"Polimorfismo por inclusão.";"Polimorfismo por sobrecarga.";"Polimorfismo por coerção.";"Polimorfismo paramétrico.";"Polimorfismo paramétrico."
M3_Q17;3;"O que é um sistema de tipo estático?";c;"A verificação de tipos ocorre durante a execução.";"A verificação de tipos é opcional.";"A verificação de tipos ocorre durante a compilação.";"A linguagem não tem tipos.";"A linguagem é puramente funcional.";"A verificação de tipos ocorre durante a compilação."
M3_Q18;3;"Qual a principal vantagem de um sistema de tipo estático?";c;"Maior flexibilidade.";"Menor segurança de tipo.";"Detecção de erros de tipo em tempo de compilação.";"Maior consumo de memória.";"Maior portabilidade.";"Detecção de erros de tipo em tempo de compilação."
M3_Q19;3;"Em um sistema de tipo forte e dinâmico, como em Python, qual o possível problema mencionado no texto?";b;"O código não pode ser compilado.";"O erro de tipo é detectado apenas em tempo de execução.";"A linguagem é fracamente tipada.";"Não há polimorfismo.";"O código é difícil de ler.";"O erro de tipo é detectado apenas em tempo de execução."
M3_Q20;3;"Qual das seguintes linguagens é um exemplo de sistema de tipo forte e estático?";e;"Python";"JavaScript";"C";"PHP";"Java";"Java"
M4_Q1;4;"Qual a relação fundamental entre a arquitetura de von Neumann e o projeto de linguagens imperativas?";d;"A arquitetura de von Neumann não tem relação com o paradigma imperativo.";"Linguagens imperativas foram projetadas para arquiteturas de processamento paralelo.";"A arquitetura de von Neumann inspira linguagens funcionais e não imperativas.";"A maioria das linguagens imperativas populares foram projetadas em torno da arquitetura de von Neumann, que influencia o uso de variáveis e comandos.";"A arquitetura de von Neumann foi um modelo que substituiu a arquitetura imperativa.";"A maioria das linguagens imperativas populares foram projetadas em torno da arquitetura de von Neumann, que influencia o uso de variáveis e comandos."
M4_Q2;4;"O que é uma variável na programação imperativa, de acordo com o documento?";a;"Uma entidade que contém um valor que pode ser avaliado e alterado.";"Uma entidade que só pode ser lida.";"Uma constante que nunca muda de valor.";"Uma função que retorna um valor.";"Uma entidade que só existe em tempo de compilação.";"Uma entidade que contém um valor que pode ser avaliado e alterado."
M4_Q3;4;"Qual a principal diferença entre variáveis 'primitivas' e 'compostas'?";d;"Primitivas são mais rápidas que compostas.";"Compostas armazenam apenas números inteiros.";"Primitivas são alocadas no heap enquanto compostas são no stack.";"Primitivas armazenam valores de tipos primitivos, enquanto compostas possuem campos que são também variáveis.";"Primitivas não podem ser alteradas.";"Primitivas armazenam valores de tipos primitivos, enquanto compostas possuem campos que são também variáveis."
M4_Q4;4;"De acordo com a classificação quanto ao tempo de vida, o que é uma variável 'persistente'?";c;"Uma variável criada e usada apenas dentro de um programa.";"Uma variável alocada no stack.";"Uma variável que tem existência independente do tempo de vida do programa (arquivos).";"Uma variável que não pode ser destruída.";"Uma variável que muda de valor constantemente.";"Uma variável que tem existência independente do tempo de vida do programa (arquivos)."
M4_Q5;4;"O que é uma 'variável de heap'?";a;"Uma variável criada ou inicializada em tempo de execução, com alocação dinâmica de memória.";"Uma variável que é sempre declarada e inicializada no início da execução.";"Uma variável que só armazena tipos primitivos.";"Uma variável com alocação estática.";"Uma variável que não pode ser desalocada.";"Uma variável criada ou inicializada em tempo de execução, com alocação dinâmica de memória."
M4_Q6;4;"Qual a definição de 'tempo de vida' de uma variável?";e;"O número de linhas de código em que ela é usada.";"O momento em que ela é declarada.";"O intervalo de tempo que ela leva para ser inicializada.";"O tamanho da memória que ela ocupa.";"O intervalo de tempo entre a sua criação (alocação) e a sua destruição (desalocação).";"O intervalo de tempo entre a sua criação (alocação) e a sua destruição (desalocação)."
M4_Q7;4;"O que são 'referências soltas' (dangling references)?";b;"Apontadores para uma variável de stack desalocada.";"Apontadores para uma variável de heap que foi desalocada.";"Variáveis que não têm um valor.";"Variáveis que são sempre globais.";"Variáveis de tipos primitivos.";"Apontadores para uma variável de heap que foi desalocada."
M4_Q8;4;"O que é 'escopo' de uma variável?";c;"O tempo que a variável leva para ser criada.";"O valor que a variável armazena.";"As partes do programa que podem acessar essa variável.";"A sua classificação como primitiva ou composta.";"O tipo de memória em que a variável é alocada.";"As partes do programa que podem acessar essa variável."
M4_Q9;4;"O que caracteriza o 'escopo dinâmico'?";d;"O escopo é determinado pela estrutura textual do programa.";"O escopo de uma variável não pode ser alterado.";"O escopo é definido antes da execução.";"O escopo é determinado pela linha de execução do programa e depende da ordem de execução das rotinas.";"O escopo é sempre global.";"O escopo é determinado pela linha de execução do programa e depende da ordem de execução das rotinas."
M4_Q10;4;"Qual a principal desvantagem do 'escopo dinâmico' mencionada no documento?";e;"Aumenta a legibilidade.";"Promove o encapsulamento.";"Facilita a compreensão do código.";"É dependente da ordem de declaração das funções.";"Fica difícil acompanhar quais variáveis estão visíveis e prejudica o encapsulamento.";"Fica difícil acompanhar quais variáveis estão visíveis e prejudica o encapsulamento."
M4_Q11;4;"No 'escopo léxico', o que determina a definição do escopo?";a;"A estrutura 'textual' do programa.";"A ordem de execução das rotinas.";"O tipo de dado da variável.";"A quantidade de memória disponível.";"O número de chamadas de funções.";"A estrutura 'textual' do programa."
M4_Q12;4;"Qual a principal diferença entre 'expressões' e 'comandos'?";e;"Expressões modificam estados e comandos leem estados.";"Ambos modificam estados.";"Ambos leem estados.";"Comandos são sempre mais complexos que expressões.";"Expressões leem estados e computam valores, enquanto comandos modificam estados.";"Expressões leem estados e computam valores, enquanto comandos modificam estados."
M4_Q13;4;"O que são 'comandos sequenciais'?";b;"Comandos que são executados sem uma ordem particular.";"Um conjunto de comandos executados um após o outro em uma ordem definida.";"Comandos que são executados em paralelo.";"Comandos que só podem ser usados dentro de loops.";"Comandos que modificam o estado de forma não-determinística.";"Um conjunto de comandos executados um após o outro em uma ordem definida."
M4_Q14;4;"Qual das opções não é um tipo de comando fundamental listado no documento?";a;"Atribuições recursivas.";"Atribuições.";"Chamadas de Procedimento.";"Comandos sequenciais.";"Comandos iterativos.";"Atribuições recursivas."
M4_Q15;4;"O que são 'comandos colaterais'?";c;"Comandos que são executados em ordem definida.";"Comandos que não modificam o estado.";"Um conjunto de comandos não-determinísticos, executados sem uma ordem particular.";"Comandos que são usados apenas em programação orientada a objetos.";"Comandos que não podem ser usados em conjunto.";"Um conjunto de comandos não-determinísticos, executados sem uma ordem particular."
M4_Q16;4;"O que 'transparência referencial' significa para uma linguagem de programação?";d;"O uso de variáveis globais é proibido.";"A alocação de memória é sempre estática.";"Um programa pode ser lido de forma sequencial.";"Qualquer expressão pode ser substituída por outra que tenha o mesmo valor sem impacto.";"Uma linguagem com alta portabilidade.";"Qualquer expressão pode ser substituída por outra que tenha o mesmo valor sem impacto."
M4_Q17;4;"Qual o problema de uma linguagem imperativa não ter 'transparência referencial'?";e;"O código é sempre mais conciso.";"Não existem efeitos colaterais.";"Um compilador não pode ser usado.";"O uso de jumps é impossível.";"A avaliação de uma expressão pode alterar variáveis, impactando o comportamento do sistema.";"A avaliação de uma expressão pode alterar variáveis, impactando o comportamento do sistema."
M4_Q18;4;"O que é um 'sequenciador'?";a;"Uma construção que transfere o controle para outro ponto do programa.";"Uma construção que lê valores e não os modifica.";"Uma variável que só pode ser usada em funções.";"Uma linguagem de programação com escopo estático.";"Uma operação de atribuição simples.";"Uma construção que transfere o controle para outro ponto do programa."
M4_Q19;4;"O que o uso irrestrito de 'jumps' (goto) pode gerar?";d;"Um fluxo de controle única-entrada, única-saída.";"Um código mais legível.";"Um programa sem sequenciadores.";"Programas do tipo 'spaghetti' com múltiplas-entradas e múltiplas-saídas.";"Um fluxo de controle única-entrada, múltiplas-saídas.";"Programas do tipo 'spaghetti' com múltiplas-entradas e múltiplas-saídas."
M4_Q20;4;"O que o comando 'break' em Java representa?";b;"Um comando de atribuição.";"Um tipo de 'escape' que termina a execução de um comando composto.";"Um comando iterativo definido.";"Um tipo de 'jump' incondicional.";"Um comando condicional.";"Um tipo de 'escape' que termina a execução de um comando composto."
M5_Q1;5;"Em um sistema de tipagem forte e estático como o de Java, por que o polimorfismo de inclusão (relacionado à herança) é crucial para a reusabilidade de código?";c;"Porque ele permite a verificação de tipos apenas em tempo de execução.";"Porque ele torna a linguagem mais fracamente tipada.";"Porque permite que um tipo possa ser substituído por um subtipo sem comprometer a segurança de tipo.";"Porque ele é um tipo de polimorfismo ad-hoc.";"Porque ele ignora a verificação de tipos.";"Porque permite que um tipo possa ser substituído por um subtipo sem comprometer a segurança de tipo."
M5_Q2;5;"Qual a relação entre a linguagem Lisp (Missão 1) e o paradigma funcional (Missão 2)?";a;"Lisp é considerada a precursora do paradigma funcional, focando na aplicação e avaliação de funções.";"Lisp é uma linguagem puramente imperativa.";"Lisp é uma linguagem que só utiliza escopo dinâmico.";"Lisp não tem relação com o paradigma funcional.";"Lisp é uma linguagem fracamente tipada.";"Lisp é considerada a precursora do paradigma funcional, focando na aplicação e avaliação de funções."
M5_Q3;5;"A ausência de 'transparência referencial' nas linguagens imperativas (Missão 4) é uma consequência de qual característica fundamental dessas linguagens?";d;"O uso de polimorfismo.";"A tipagem estática.";"A alocação de memória no stack.";"O uso de variáveis mutáveis e comandos que alteram o estado do programa.";"O uso de escopo léxico.";"O uso de variáveis mutáveis e comandos que alteram o estado do programa."
M5_Q4;5;"Por que o uso irrestrito de 'jumps' (goto) se opõe aos princípios da programação estruturada introduzidos por linguagens como Algol-60 (Missão 1)?";e;"Porque 'jumps' promovem o encapsulamento.";"Porque 'jumps' são exclusivos de linguagens de alto nível.";"Porque 'jumps' aumentam a legibilidade do código.";"Porque 'jumps' garantem a transparência referencial.";"Porque 'jumps' criam um fluxo de controle múltiplas-entradas e múltiplas-saídas, dificultando a compreensão do código.";"Porque 'jumps' criam um fluxo de controle múltiplas-entradas e múltiplas-saídas, dificultando a compreensão do código."
M5_Q5;5;"Em um compilador, a 'Análise Léxica' (Missão 2) transforma o código fonte em tokens. O que a 'Análise Semântica' (Missão 2) faz em seguida?";b;"Verifica se o programa está bem formatado.";"Verifica o significado do programa, garantindo que as operações e tipos sejam compatíveis.";"Traduz os tokens para linguagem de máquina.";"Gera código de montagem.";"Otimiza o código.";"Verifica o significado do programa, garantindo que as operações e tipos sejam compatíveis."
M5_Q6;5;"Qual a relação entre o 'escopo léxico' (Missão 4) e o conceito de programação estruturada (Missão 1)?";c;"Escopo léxico é usado apenas em linguagens funcionais.";"Escopo léxico é determinado pela ordem de execução.";"Escopo léxico é determinado pela estrutura textual do programa, o que facilita a compreensão e organiza o código em blocos.";"Escopo léxico não tem relação com a programação estruturada.";"Escopo léxico é mais difícil de depurar.";"Escopo léxico é determinado pela estrutura textual do programa, o que facilita a compreensão e organiza o código em blocos."
M5_Q7;5;"Considere a linguagem C (Missão 1) com seu sistema de tipo estático (Missão 3). Qual a principal diferença em como ela lida com 'referências soltas' (Missão 4) em comparação com linguagens com gerenciamento automático de memória?";a;"C exige gerenciamento manual de memória, o que aumenta a probabilidade de 'dangling references' se a memória de heap for desalocada incorretamente.";"C é uma linguagem de alto nível que previne 'dangling references'.";"Em C, 'dangling references' não são um problema.";"C não tem ponteiros.";"Em C, as 'dangling references' são detectadas em tempo de compilação.";"C exige gerenciamento manual de memória, o que aumenta a probabilidade de 'dangling references' se a memória de heap for desalocada incorretamente."
M5_Q8;5;"O que o conceito de 'monomorfismo' (Missão 3) representa em contraste com a 'expressividade' de uma LP (Missão 1)?";d;"Monomorfismo aumenta a expressividade.";"Monomorfismo não tem relação com a expressividade.";"Monomorfismo é uma forma de polimorfismo universal.";"Monomorfismo limita a capacidade de escrever código genérico, diminuindo a expressividade de uma linguagem.";"Monomorfismo é um erro de compilação.";"Monomorfismo limita a capacidade de escrever código genérico, diminuindo a expressividade de uma linguagem."
M5_Q9;5;"Qual é a principal razão pela qual linguagens interpretadas (Missão 2) são frequentemente mais portáveis que linguagens compiladas (Missão 2)?";b;"Linguagens interpretadas traduzem o código para código de máquina antes da execução.";"O interpretador pode ser escrito para diferentes arquiteturas, permitindo que o mesmo código fonte seja executado em múltiplos sistemas.";"Linguagens interpretadas são sempre mais eficientes.";"Linguagens interpretadas têm menos recursos.";"Linguagens interpretadas não têm fases de análise.";"O interpretador pode ser escrito para diferentes arquiteturas, permitindo que o mesmo código fonte seja executado em múltiplos sistemas."
M5_Q10;5;"O que o conceito de 'valores de primeira classe' (Missão 3) tem em comum com o paradigma funcional (Missão 2)?";a;"Permite que funções sejam tratadas como valores, o que é fundamental para o paradigma funcional.";"Não há relação entre os dois.";"Valores de primeira classe são exclusivos de linguagens imperativas.";"O paradigma funcional não utiliza valores de primeira classe.";"Valores de primeira classe são sempre mutáveis.";"Permite que funções sejam tratadas como valores, o que é fundamental para o paradigma funcional."
M5_Q11;5;"Qual a relação entre a arquitetura de von Neumann (Missão 4) e o conceito de 'comandos' (Missão 4)?";d;"A arquitetura de von Neumann não tem comandos.";"Comandos são a mesma coisa que expressões.";"Comandos são uma abstração de alto nível que não se relaciona com a máquina.";"Comandos são baseados nas operações de transferência de dados e instruções da arquitetura de von Neumann.";"Comandos são usados apenas em linguagens declarativas.";"Comandos são baseados nas operações de transferência de dados e instruções da arquitetura de von Neumann."
M5_Q12;5;"O que um sistema de tipagem forte e dinâmico como o de Python (Missão 3) pode permitir em tempo de execução?";b;"Erros de tipo serem detectados em tempo de compilação.";"Uma variável assumir valores de tipos diferentes, o que pode levar a erros de tipo em tempo de execução.";"Ponteiros para memória desalocada.";"Não há polimorfismo.";"Um código não ser interpretado.";"Uma variável assumir valores de tipos diferentes, o que pode levar a erros de tipo em tempo de execução."
M5_Q13;5;"Como a 'simplicidade' de uma LP (Missão 1) se relaciona com a existência de 'efeitos colaterais' (Missão 4)?";c;"Simplicidade garante que haverá efeitos colaterais.";"Não há relação entre os dois.";"A simplicidade de uma linguagem é prejudicada por efeitos colaterais que podem tornar o código mais difícil de entender e depurar.";"Linguagens simples não têm efeitos colaterais.";"Efeitos colaterais simplificam o código.";"A simplicidade de uma linguagem é prejudicada por efeitos colaterais que podem tornar o código mais difícil de entender e depurar."
M5_Q14;5;"Em um programa imperativo, por que o 'tempo de vida' das variáveis (Missão 4) é uma preocupação?";a;"Porque um gerenciamento inadequado da memória pode causar 'dangling references' ou vazamentos de memória.";"Porque o tempo de vida não tem relação com a alocação de memória.";"Porque o tempo de vida é sempre estático.";"Porque o tempo de vida é determinado pelo escopo dinâmico.";"Porque o tempo de vida é gerenciado automaticamente em todas as linguagens.";"Porque um gerenciamento inadequado da memória pode causar 'dangling references' ou vazamentos de memória."
M5_Q15;5;"O que diferencia o paradigma imperativo (Missão 2) do paradigma declarativo (Missão 2)?";d;"O paradigma imperativo descreve o que fazer, enquanto o declarativo descreve como fazer.";"O paradigma declarativo não usa variáveis.";"O paradigma declarativo é sempre interpretado.";"O paradigma imperativo foca em como resolver um problema através de uma sequência de comandos, enquanto o declarativo foca em descrever o que se quer como resultado.";"O paradigma imperativo é mais eficiente.";"O paradigma imperativo foca em como resolver um problema através de uma sequência de comandos, enquanto o declarativo foca em descrever o que se quer como resultado."
M5_Q16;5;"Qual a relação entre a 'análise sintática' de um compilador (Missão 2) e a gramática de uma LP (Missão 2)?";e;"A análise sintática verifica o significado do programa.";"A análise sintática traduz o programa.";"A gramática é usada na análise léxica.";"Não há relação entre eles.";"A análise sintática verifica se a estrutura do programa está em conformidade com as regras definidas pela gramática.";"A análise sintática verifica se a estrutura do programa está em conformidade com as regras definidas pela gramática."
M5_Q17;5;"Qual tipo de polimorfismo (Missão 3) se aproxima mais da ideia de 'sobrecarga' (Missão 3)?";b;"Polimorfismo paramétrico.";"Polimorfismo ad-hoc.";"Polimorfismo de inclusão.";"Polimorfismo universal.";"Monomorfismo.";"Polimorfismo ad-hoc."
M5_Q18;5;"Como a 'eficiência' de uma LP (Missão 1) se relaciona com a escolha entre uma linguagem compilada ou interpretada (Missão 2)?";a;"Linguagens compiladas tendem a ser mais eficientes, pois a tradução para código de máquina é feita antes da execução.";"Linguagens interpretadas são sempre mais eficientes.";"A eficiência não depende da forma de tradução.";"Linguagens compiladas têm menor portabilidade.";"Linguagens interpretadas não consomem memória.";"Linguagens compiladas tendem a ser mais eficientes, pois a tradução para código de máquina é feita antes da execução."
M5_Q19;5;"Em uma linguagem com 'escopo dinâmico' (Missão 4), o que determina o acesso a uma variável local?";d;"A estrutura textual do programa.";"O tipo da variável.";"A sua alocação no stack.";"A sequência de chamadas de rotinas durante a execução.";"A sua alocação no heap.";"A sequência de chamadas de rotinas durante a execução."
M5_Q20;5;"Qual a principal diferença entre 'expressões' e 'comandos' no contexto do paradigma imperativo (Missão 4) e como isso se relaciona com a 'transparência referencial'?";e;"Comandos retornam valores e expressões modificam estados.";"Ambos são transparentes referencialmente.";"Comandos não podem ter efeitos colaterais.";"Expressões causam efeitos colaterais.";"Comandos modificam o estado (causando efeitos colaterais), enquanto expressões apenas computam um valor, e a transparência referencial só é possível para expressões.";"Comandos modificam o estado (causando efeitos colaterais), enquanto expressões apenas computam um valor, e a transparência referencial só é possível para expressões."
M6_Q1;6;"Qual a principal característica do paradigma funcional?";c;"Utiliza comandos que modificam o estado do programa.";"Foca em como resolver um problema passo a passo.";"Trata a computação como a avaliação de funções matemáticas e evita estados mutáveis.";"É um estilo de programação que se baseia em herança e polimorfismo.";"É um paradigma que se baseia em consultas a uma base de fatos.";"Trata a computação como a avaliação de funções matemáticas e evita estados mutáveis."
M6_Q2;6;"O que é uma 'função pura' no paradigma funcional?";b;"Uma função que pode ter efeitos colaterais.";"Uma função cujo resultado depende apenas de seus argumentos e não possui efeitos colaterais.";"Uma função que sempre retorna um valor booleano.";"Uma função que só pode ser usada uma vez.";"Uma função que manipula variáveis globais.";"Uma função cujo resultado depende apenas de seus argumentos e não possui efeitos colaterais."
M6_Q3;6;"Qual o papel da 'imutabilidade' no paradigma funcional?";a;"Variáveis e estruturas de dados não podem ser alteradas após a criação, o que previne efeitos colaterais.";"Torna o código mais difícil de entender.";"Aumenta a complexidade do gerenciamento de memória.";"Apenas tipos primitivos são imutáveis.";"Não é um conceito importante no paradigma.";"Variáveis e estruturas de dados não podem ser alteradas após a criação, o que previne efeitos colaterais."
M6_Q4;6;"O que 'transparência referencial' significa no contexto de uma linguagem funcional?";d;"Que a linguagem não utiliza funções.";"Que o código é sempre mais conciso.";"Que a avaliação de uma expressão pode alterar o estado do programa.";"Que uma expressão pode ser substituída por seu valor sem alterar o comportamento do programa.";"Que todas as funções são impuras.";"Que uma expressão pode ser substituída por seu valor sem alterar o comportamento do programa."
M6_Q5;6;"O que é uma 'função de ordem superior' (higher-order function)?";e;"Uma função que não pode ser passada como argumento.";"Uma função que não pode retornar outra função.";"Uma função que opera apenas em números inteiros.";"Uma função que tem apenas um argumento.";"Uma função que pode receber outras funções como argumentos ou retornar uma função como resultado.";"Uma função que pode receber outras funções como argumentos ou retornar uma função como resultado."
M6_Q6;6;"Por que a 'recursão' é a principal forma de iteração no paradigma funcional?";a;"Porque a programação funcional usa comandos de atribuição e loops.";"Porque a recursão é menos eficiente que loops.";"Porque a recursão é a única maneira de criar efeitos colaterais.";"Porque o estado mutável é evitado e a recursão não depende de variáveis de controle de loop.";"Porque linguagens funcionais não suportam funções.";"Porque o estado mutável é evitado e a recursão não depende de variáveis de controle de loop."
M6_Q7;6;"Qual a função do 'lambda calculus' no paradigma funcional?";b;"É a principal forma de iteração.";"É a base teórica para a computação funcional.";"É um sistema de tipos para linguagens funcionais.";"É um tipo de polimorfismo.";"É uma linguagem de programação imperativa.";"É a base teórica para a computação funcional."
M6_Q8;6;"Qual das seguintes linguagens é um exemplo de linguagem puramente funcional?";d;"Java";"Python";"C";"Haskell";"Javascript";"Haskell"
M6_Q9;6;"Qual a principal desvantagem de funções com 'efeitos colaterais'?";c;"Elas são mais fáceis de testar.";"Elas aumentam a transparência referencial.";"Elas tornam o código mais difícil de raciocinar, testar e paralelizar.";"Elas são essenciais para o paradigma funcional.";"Elas não podem receber argumentos.";"Elas tornam o código mais difícil de raciocinar, testar e paralelizar."
M6_Q10;6;"O que é 'avaliação preguiçosa' (lazy evaluation)?";e;"Todas as expressões são avaliadas imediatamente.";"É um tipo de sobrecarga de operadores.";"É um recurso exclusivo de linguagens imperativas.";"As funções não podem ser avaliadas.";"As expressões só são avaliadas quando seu valor é realmente necessário.";"As expressões só são avaliadas quando seu valor é realmente necessário."
M6_Q11;6;"O que é 'currying' em programação funcional?";a;"A prática de passar todos os argumentos de uma função de uma vez só.";"Um tipo de polimorfismo.";"Um erro de compilação.";"A prática de converter uma função que aceita vários argumentos em uma sequência de funções que aceitam um único argumento.";"Um tipo de estrutura de dados.";"A prática de converter uma função que aceita vários argumentos em uma sequência de funções que aceitam um único argumento."
M6_Q12;6;"Qual das seguintes afirmações é verdadeira sobre o estado no paradigma funcional?";b;"O estado é central e constantemente modificado.";"O estado é evitado e representado como o valor de retorno de funções.";"O estado é gerenciado por comandos de atribuição.";"O estado é sempre global.";"O estado não existe.";"O estado é evitado e representado como o valor de retorno de funções."
M6_Q13;6;"Por que a programação funcional é considerada mais adequada para a programação paralela e concorrente?";d;"Porque usa o estado compartilhado.";"Porque é uma linguagem interpretada.";"Porque o código não é transparente referencialmente.";"Porque a ausência de efeitos colaterais elimina a necessidade de bloqueios e mecanismos de sincronização.";"Porque é uma linguagem puramente imperativa.";"Porque a ausência de efeitos colaterais elimina a necessidade de bloqueios e mecanismos de sincronização."
M6_Q14;6;"Qual é a principal diferença entre programação funcional e imperativa?";c;"Funcional foca em como resolver um problema, enquanto imperativa foca em o que resolver.";"Imperativa usa funções de ordem superior, enquanto funcional não.";"Funcional foca em o que calcular, usando a avaliação de funções. Imperativa foca em como calcular, usando sequências de comandos.";"Não há diferença significativa.";"Funcional é sempre compilada, enquanto imperativa é sempre interpretada.";"Funcional foca em o que calcular, usando a avaliação de funções. Imperativa foca em como calcular, usando sequências de comandos."
M6_Q15;6;"O que o conceito de 'monads' permite em linguagens funcionais puras?";e;"O uso de variáveis mutáveis.";"O uso de loops for.";"O uso de comandos goto.";"A criação de efeitos colaterais de forma incontrolável.";"O tratamento de efeitos colaterais de forma controlada e segura.";"O tratamento de efeitos colaterais de forma controlada e segura."
M6_Q16;6;"A linguagem Python é considerada puramente funcional?";d;"Sim, porque ela suporta funções de ordem superior.";"Sim, porque ela é dinamicamente tipada.";"Não, é uma linguagem puramente imperativa.";"Não, é uma linguagem multiparadigma que incorpora elementos funcionais, mas também tem estado mutável e comandos.";"Sim, porque ela não tem efeitos colaterais.";"Não, é uma linguagem multiparadigma que incorpora elementos funcionais, mas também tem estado mutável e comandos."
M6_Q17;6;"O que é um 'fechamento' (closure)?";a;"Uma função que 'captura' variáveis de seu escopo circundante, mesmo que o escopo não exista mais.";"Um bloco de código que nunca pode ser executado.";"Uma função que só tem argumentos.";"Um tipo de dado imutável.";"Uma estrutura de controle de loop.";"Uma função que 'captura' variáveis de seu escopo circundante, mesmo que o escopo não exista mais."
M6_Q18;6;"Qual das seguintes LP não é classificada como sendo funcional?";c;"Haskell";"Lisp";"C++";"OCaml";"Erlang";"C++"
M6_Q19;6;"Qual a vantagem de usar 'funções puras' em um código?";e;"Aumentam os efeitos colaterais.";"São mais difíceis de depurar.";"Dependem de variáveis globais.";"Diminuem a transparência referencial.";"São fáceis de testar e o seu comportamento é previsível e isolado.";"São fáceis de testar e o seu comportamento é previsível e isolado."
M6_Q20;6;"O que é 'imutabilidade' em uma estrutura de dados como uma lista ligada?";b;"Os elementos da lista podem ser modificados a qualquer momento.";"Nenhum elemento da lista pode ser modificado. Para alterações, uma nova lista é criada.";"A lista é sempre vazia.";"A lista é sempre global.";"A lista só pode ter um elemento.";"Nenhum elemento da lista pode ser modificado. Para alterações, uma nova lista é criada."
M7_Q1;7;"No paradigma funcional, qual a relação entre 'imutabilidade' e 'transparência referencial'?";e;"Imutabilidade causa efeitos colaterais.";"Transparência referencial só existe em linguagens imperativas.";"Não há relação entre os dois conceitos.";"A imutabilidade é uma consequência da transparência referencial.";"A imutabilidade é uma condição necessária para alcançar a transparência referencial, pois garante que uma expressão não causará efeitos colaterais.";"A imutabilidade é uma condição necessária para alcançar a transparência referencial, pois garante que uma expressão não causará efeitos colaterais."
M7_Q2;7;"Por que a 'recursão de cauda' (tail recursion) é uma otimização importante em linguagens funcionais?";a;"Ela não é mais eficiente que a recursão normal.";"Ela aumenta o consumo de memória.";"Ela permite a transformação de uma chamada recursiva em um loop, evitando o estouro da pilha.";"É um recurso exclusivo de linguagens imperativas.";"Ela aumenta os efeitos colaterais.";"Ela permite a transformação de uma chamada recursiva em um loop, evitando o estouro da pilha."
M7_Q3;7;"No paradigma funcional, por que as 'funções puras' são consideradas ideais para a programação paralela?";c;"Porque elas dependem de um estado compartilhado.";"Porque elas criam efeitos colaterais.";"Porque o resultado de uma função pura depende apenas de seus argumentos, permitindo que a execução seja realizada em paralelo sem problemas de sincronização.";"Porque elas são mais difíceis de testar.";"Porque elas não podem ser usadas em funções de ordem superior.";"Porque o resultado de uma função pura depende apenas de seus argumentos, permitindo que a execução seja realizada em paralelo sem problemas de sincronização."
M7_Q4;7;"Qual é a principal vantagem de 'funções de ordem superior' (higher-order functions) em relação à expressividade de uma linguagem?";b;"Elas tornam o código mais difícil de ler.";"Elas permitem a criação de abstrações de controle e a reusabilidade de código de forma mais concisa.";"Elas são usadas apenas para lidar com efeitos colaterais.";"Elas limitam a programação a um único tipo de dados.";"Elas não podem ser passadas como argumentos.";"Elas permitem a criação de abstrações de controle e a reusabilidade de código de forma mais concisa."
M7_Q5;7;"Como o conceito de 'currying' se relaciona com 'funções de ordem superior'?";e;"Currying não tem relação com funções de ordem superior.";"Currying é um tipo de polimorfismo.";"Currying é a prática de criar funções que aceitam todos os seus argumentos de uma vez.";"Currying é um recurso exclusivo de linguagens imperativas.";"Currying é uma aplicação de funções de ordem superior que permite a criação de novas funções com base em funções existentes com alguns argumentos fixos.";"Currying é uma aplicação de funções de ordem superior que permite a criação de novas funções com base em funções existentes com alguns argumentos fixos."
M7_Q6;7;"O que a 'avaliação preguiçosa' (lazy evaluation) permite em linguagens funcionais puras como Haskell?";a;"A avaliação de expressões imediatamente.";"O uso de loops for.";"A criação de efeitos colaterais incontroláveis.";"A manipulação de estados mutáveis.";"Permite a construção de estruturas de dados infinitas e otimizações de desempenho, pois só avalia o que é necessário.";"Permite a construção de estruturas de dados infinitas e otimizações de desempenho, pois só avalia o que é necessário."
M7_Q7;7;"Em um programa funcional, como a 'recursão' substitui os 'loops' imperativos?";d;"A recursão utiliza variáveis mutáveis para controlar o loop.";"A recursão é um tipo de comando.";"A recursão é menos eficiente que loops.";"A recursão usa a chamada da própria função para iterar, sem a necessidade de modificar variáveis de estado.";"A recursão só é possível em linguagens impuras.";"A recursão usa a chamada da própria função para iterar, sem a necessidade de modificar variáveis de estado."
M7_Q8;7;"Qual a principal diferença na abordagem entre o paradigma funcional e o paradigma imperativo?";c;"Funcional foca em como resolver um problema, imperativo em o que resolver.";"Imperativo usa funções de ordem superior, funcional não.";"Funcional foca na expressão e avaliação de funções, enquanto imperativo foca na sequência de comandos e manipulação de estado.";"Não há diferença significativa.";"Funcional é sempre compilado, imperativo sempre interpretado.";"Funcional foca na expressão e avaliação de funções, enquanto imperativo foca na sequência de comandos e manipulação de estado."
M7_Q9;7;"O que é um 'fechamento' (closure) no contexto funcional?";b;"Um bloco de código que nunca pode ser executado.";"Uma função que 'captura' variáveis de seu escopo circundante e pode acessá-las mesmo após o escopo não existir mais.";"Uma função que não tem argumentos.";"Um tipo de dado imutável.";"Uma estrutura de controle de loop.";"Uma função que 'captura' variáveis de seu escopo circundante e pode acessá-las mesmo após o escopo não existir mais."
M7_Q10;7;"Como a 'imutabilidade' ajuda a evitar 'referências soltas' (dangling references) em linguagens funcionais?";a;"A imutabilidade não tem relação com referências soltas.";"A imutabilidade causa referências soltas.";"Como os dados não são alterados, não há a necessidade de desalocação dinâmica, eliminando a fonte do problema.";"A imutabilidade é um tipo de escopo dinâmico.";"A imutabilidade só existe em linguagens com gerenciamento manual de memória.";"Como os dados não são alterados, não há a necessidade de desalocação dinâmica, eliminando a fonte do problema."
M7_Q11;7;"Qual o papel da 'semântica' de uma linguagem (Missão 2) em um programa funcional?";d;"A semântica não é importante no paradigma funcional.";"A semântica lida apenas com a sintaxe.";"A semântica verifica o formato do código.";"A semântica define o significado das funções e expressões, garantindo a correção e previsibilidade do código.";"A semântica é usada para traduzir o código.";"A semântica define o significado das funções e expressões, garantindo a correção e previsibilidade do código."
M7_Q12;7;"No paradigma funcional, o que o 'lambda calculus' representa?";c;"É um tipo de dado.";"É uma linguagem de programação de alto nível.";"É a base teórica formal para a computação funcional e o estudo de funções.";"É um sistema de tipos para linguagens funcionais.";"É uma forma de polimorfismo.";"É a base teórica formal para a computação funcional e o estudo de funções."
M7_Q13;7;"Qual a principal consequência da 'ausência de efeitos colaterais' em um programa funcional?";e;"Aumento da complexidade.";"Dificuldade para testar o código.";"Menor portabilidade.";"O código se torna menos previsível.";"O comportamento de uma função é totalmente previsível e o paralelismo é mais fácil de ser implementado.";"O comportamento de uma função é totalmente previsível e o paralelismo é mais fácil de ser implementado."
M7_Q14;7;"Em que sentido o 'polimorfismo paramétrico' (Missão 3) se alinha com os princípios do paradigma funcional?";a;"Polimorfismo paramétrico não se alinha com o paradigma funcional.";"O polimorfismo paramétrico é um tipo de polimorfismo ad-hoc.";"O polimorfismo paramétrico promove a criação de funções genéricas que não dependem do tipo de dado, promovendo a reutilização de código e a imutabilidade.";"O polimorfismo paramétrico é exclusivo de linguagens imperativas.";"O polimorfismo paramétrico é uma forma de coerção.";"O polimorfismo paramétrico promove a criação de funções genéricas que não dependem do tipo de dado, promovendo a reutilização de código e a imutabilidade."
M7_Q15;7;"Como o conceito de 'monads' é utilizado em linguagens funcionais puras como Haskell?";b;"Para criar efeitos colaterais de forma incontrolável.";"Para lidar com efeitos colaterais como entrada/saída de forma controlada e segura.";"Para criar variáveis mutáveis.";"Para implementar loops for.";"Monads são um tipo de dado primitivo.";"Para lidar com efeitos colaterais como entrada/saída de forma controlada e segura."
M7_Q16;7;"Por que a 'tipagem forte' e 'estática' é frequentemente encontrada em linguagens funcionais como Haskell?";d;"Para permitir a conversão implícita de tipos.";"Para diminuir a expressividade da linguagem.";"Porque a tipagem dinâmica é mais segura.";"Para garantir a correção do programa em tempo de compilação e evitar erros de tipo em tempo de execução.";"Porque a tipagem estática não suporta polimorfismo.";"Para garantir a correção do programa em tempo de compilação e evitar erros de tipo em tempo de execução."
M7_Q17;7;"Em linguagens multiparadigmas como Python ou OCaml, qual a principal diferença na implementação do paradigma funcional em relação a linguagens puramente funcionais?";c;"Elas não suportam funções de ordem superior.";"Elas não têm funções puras.";"Elas permitem a combinação de funções e imutabilidade com comandos imperativos e estados mutáveis.";"Elas são puramente funcionais.";"Elas não têm um sistema de tipos.";"Elas permitem a combinação de funções e imutabilidade com comandos imperativos e estados mutáveis."
M7_Q18;7;"O que é o conceito de 'composição de funções' (function composition) e por que é importante no paradigma funcional?";a;"A prática de passar uma função como argumento para outra.";"É um tipo de loop.";"É o mesmo que sobrecarga de operadores.";"É um erro de compilação.";"É a prática de combinar funções menores para construir funções mais complexas, promovendo a modularidade e o reuso.";"É a prática de combinar funções menores para construir funções mais complexas, promovendo a modularidade e o reuso."
M7_Q19;7;"Qual é a principal desvantagem da 'avaliação preguiçosa'?";e;"Maior consumo de memória.";"Maior dificuldade em paralelizar.";"Não permite a construção de estruturas de dados infinitas.";"Não é eficiente.";"A dificuldade em prever o momento exato da avaliação, o que pode levar a um desempenho inesperado e a maior consumo de memória.";"A dificuldade em prever o momento exato da avaliação, o que pode levar a um desempenho inesperado e a maior consumo de memória."
M7_Q20;7;"No paradigma funcional, qual o principal objetivo dos 'sistemas de tipos'?";b;"Permitir o uso de variáveis mutáveis.";"Garantir que as operações com funções e dados sejam seguras e consistentes em tempo de compilação.";"Promover o uso de efeitos colaterais.";"Diminuir a reusabilidade de código.";"Impedir a criação de funções de ordem superior.";"Garantir que as operações com funções e dados sejam seguras e consistentes em tempo de compilação."
M8_Q1;8;"Qual é a principal característica do paradigma de programação lógica?";c;"Focar em como resolver um problema passo a passo.";"Utilizar funções puras e imutabilidade.";"Descrever o problema em termos de fatos e regras e deixar que o interpretador infira a solução.";"Usar variáveis mutáveis e comandos.";"Separar a interface gráfica da lógica do programa.";"Descrever o problema em termos de fatos e regras e deixar que o interpretador infira a solução."
M8_Q2;8;"A linguagem Prolog, principal exemplo de programação lógica, se baseia em qual área da matemática?";d;"Cálculo diferencial.";"Álgebra linear.";"Teoria dos grafos.";"Lógica de predicados de primeira ordem.";"Estatística.";"Lógica de predicados de primeira ordem."
M8_Q3;8;"O que um 'programa lógico' é composto?";a;"De fatos, regras de inferência e perguntas sobre esses fatos e regras.";"De uma sequência de comandos e atribuições.";"De funções e listas.";"De classes e objetos.";"De eventos e handlers.";"De fatos, regras de inferência e perguntas sobre esses fatos e regras."
M8_Q4;8;"O que é um 'fato' em um programa lógico?";b;"Uma expressão que pode ser avaliada.";"Uma proposição que é declarada como verdadeira.";"Uma variável que pode ser modificada.";"Um comando que altera o estado do programa.";"Uma função que retorna um valor.";"Uma proposição que é declarada como verdadeira."
M8_Q5;8;"Como o interpretador do paradigma lógico encontra a solução para uma pergunta?";e;"Executando uma sequência de comandos.";"Usando um algoritmo de ordenação.";"Modificando o valor de variáveis.";"Aplicando funções.";"Fazendo uma busca na base de conhecimento (fatos e regras) para unificar a pergunta com fatos ou regras.";"Fazendo uma busca na base de conhecimento (fatos e regras) para unificar a pergunta com fatos ou regras."
M8_Q6;8;"O que é uma 'regra de inferência'?";c;"Um fato que sempre é verdadeiro.";"Um comando de atribuição.";"Uma proposição que define como deduzir novos fatos a partir de fatos existentes.";"Uma função que retorna um valor.";"Uma variável global.";"Uma proposição que define como deduzir novos fatos a partir de fatos existentes."
M8_Q7;8;"O que 'unificação' significa no contexto do paradigma lógico?";d;"Um erro de compilação.";"A capacidade de um objeto ter múltiplos tipos.";"A prática de combinar funções.";"O processo de casar uma pergunta com um fato ou regra da base de conhecimento.";"O uso de loops para iteração.";"O processo de casar uma pergunta com um fato ou regra da base de conhecimento."
M8_Q8;8;"Por que o paradigma lógico é classificado como 'declarativo'?";a;"Porque o programador especifica como resolver o problema.";"Porque o foco está na modificação do estado do programa.";"Porque o programador especifica o que se quer como resultado, sem se preocupar com os detalhes de implementação.";"Porque ele é baseado em funções puras.";"Porque ele é um tipo de programação estruturada.";"Porque o programador especifica o que se quer como resultado, sem se preocupar com os detalhes de implementação."
M8_Q9;8;"Em qual área da informática o paradigma lógico é amplamente utilizado?";b;"Desenvolvimento web de front-end.";"Inteligência artificial e sistemas especialistas.";"Desenvolvimento de sistemas operacionais.";"Programação de jogos.";"Banco de dados relacionais.";"Inteligência artificial e sistemas especialistas."
M8_Q10;8;"Qual a principal diferença entre um programa lógico e um programa imperativo?";c;"Programas lógicos usam variáveis mutáveis.";"Programas lógicos são sempre compilados.";"Programas lógicos se concentram em 'o que' e programas imperativos em 'como'.";"Não há diferença.";"Programas lógicos não usam funções.";"Programas lógicos se concentram em 'o que' e programas imperativos em 'como'."
M8_Q11;8;"O que a 'recursão' representa no paradigma lógico?";e;"É a única forma de criar efeitos colaterais.";"É um tipo de comando.";"É uma operação de atribuição.";"É a forma de unificar fatos.";"É a principal forma de iteração e de processar estruturas de dados.";"É a principal forma de iteração e de processar estruturas de dados."
M8_Q12;8;"Qual é a principal vantagem do paradigma lógico para resolver problemas?";a;"Facilidade em lidar com tarefas de entrada/saída.";"Maior eficiência em cálculos numéricos.";"A possibilidade de expressar o problema de forma concisa e próxima da linguagem humana e formal.";"Não tem vantagens.";"A sintaxe é mais simples que a de outras linguagens.";"A possibilidade de expressar o problema de forma concisa e próxima da linguagem humana e formal."
M8_Q13;8;"No contexto do paradigma lógico, o que é 'backtracking'?";b;"O processo de unificar um fato.";"Um mecanismo que permite ao interpretador explorar caminhos alternativos de busca quando uma tentativa falha.";"Um erro de sintaxe.";"Um tipo de dado.";"Uma função de ordem superior.";"Um mecanismo que permite ao interpretador explorar caminhos alternativos de busca quando uma tentativa falha."
M8_Q14;8;"Prolog lida com objetos e relações entre eles. O que 'objetos' significam nesse contexto?";d;"São instâncias de classes com métodos.";"São elementos mutáveis.";"São apenas números.";"São 'coisas' sobre as quais o programa pode raciocinar, mas não têm métodos ou herança.";"São constantes.";"São 'coisas' sobre as quais o programa pode raciocinar, mas não têm métodos ou herança."
M8_Q15;8;"Qual a principal desvantagem do paradigma lógico?";c;"Dificuldade em expressar problemas complexos.";"Baixa portabilidade.";"Ineficiência e dificuldade de lidar com cálculos matemáticos complexos.";"A sintaxe é muito verbosa.";"Não suporta recursão.";"Ineficiência e dificuldade de lidar com cálculos matemáticos complexos."
M8_Q16;8;"Qual é a relação entre o paradigma lógico e o paradigma imperativo no que diz respeito ao estado do programa?";a;"O paradigma lógico não possui estado mutável, enquanto o imperativo é focado na sua modificação.";"Ambos os paradigmas são focados em modificar o estado.";"O paradigma lógico utiliza variáveis mutáveis.";"O estado é um conceito irrelevante para o paradigma lógico.";"O paradigma lógico utiliza o estado para controlar a execução.";"O paradigma lógico não possui estado mutável, enquanto o imperativo é focado na sua modificação."
M8_Q17;8;"Em um programa Prolog, o que representa uma 'pergunta' (query)?";e;"Uma atribuição de valor a uma variável.";"A definição de um novo fato.";"Uma regra de inferência.";"A declaração de uma função.";"Uma solicitação ao interpretador para tentar provar se uma proposição é verdadeira com base na base de conhecimento.";"Uma solicitação ao interpretador para tentar provar se uma proposição é verdadeira com base na base de conhecimento."
M8_Q18;8;"Como o paradigma lógico lida com a 'transparência referencial'?";b;"Não a suporta, porque o estado do programa é mutável.";"Suporta a transparência referencial porque a avaliação de uma consulta não causa efeitos colaterais.";"A transparência referencial é um conceito irrelevante.";"A transparência referencial é o que causa os efeitos colaterais.";"Só suporta a transparência referencial em funções puras.";"Suporta a transparência referencial porque a avaliação de uma consulta não causa efeitos colaterais."
M8_Q19;8;"Qual é a principal diferença entre um sistema de 'fato' e um sistema de 'regra'?";d;"Fatos são proposições que são provadas falsas.";"Regras não podem ser usadas para deduzir novos fatos.";"Fatos dependem de outras proposições.";"Fatos são proposições concretas e conhecidas, enquanto regras são proposições que definem como deduzir novos fatos.";"Não há diferença entre eles.";"Fatos são proposições concretas e conhecidas, enquanto regras são proposições que definem como deduzir novos fatos."
M8_Q20;8;"A linguagem Prolog é considerada uma linguagem de que geração?";a;"Quinta geração, voltada para inteligência artificial.";"Primeira geração, voltada para cálculos numéricos.";"Terceira geração, procedural.";"Segunda geração, de montagem.";"Quarta geração, aplicativa.";"Quinta geração, voltada para inteligência artificial."
M9_Q1;9;"Qual a relação entre a 'programação em lógica' (Missão 8) e a 'programação declarativa' (Missão 2)?";a;"O paradigma lógico é um subtipo do paradigma declarativo, pois o programador especifica o que se quer como resultado, não o como.";"O paradigma lógico é um paradigma puramente imperativo.";"O paradigma declarativo se baseia em fatos e regras.";"Não há relação entre eles.";"O paradigma lógico é a base do paradigma imperativo.";"O paradigma lógico é um subtipo do paradigma declarativo, pois o programador especifica o que se quer como resultado, não o como."
M9_Q2;9;"Como o conceito de 'unificação' (Missão 8) em Prolog é mais eficiente do que a 'busca' simples em uma base de dados?";c;"A unificação é uma operação de atribuição.";"A unificação não é um conceito importante em Prolog.";"A unificação permite casar perguntas com fatos ou regras, o que é uma forma poderosa e flexível de recuperação de informação, indo além de uma busca por valores.";"A unificação é um tipo de comando.";"A unificação só funciona com números inteiros.";"A unificação permite casar perguntas com fatos ou regras, o que é uma forma poderosa e flexível de recuperação de informação, indo além de uma busca por valores."
M9_Q3;9;"Qual é a principal diferença no uso da 'recursão' (Missão 6) entre o paradigma funcional e o paradigma lógico?";b;"O paradigma funcional usa recursão para modificar o estado, o lógico não.";"No funcional, a recursão é usada para aplicar funções a uma estrutura de dados. No lógico, é usada para percorrer a base de conhecimento durante o processo de prova.";"Não há diferença no uso.";"O paradigma funcional usa a recursão de cauda, o lógico não.";"A recursão é um conceito irrelevante para ambos.";"No funcional, a recursão é usada para aplicar funções a uma estrutura de dados. No lógico, é usada para percorrer a base de conhecimento durante o processo de prova."
M9_Q4;9;"Em relação à 'transparência referencial' (Missão 6), como o paradigma lógico se comporta em comparação ao imperativo (Missão 4)?";d;"O paradigma lógico não tem transparência referencial.";"O paradigma imperativo suporta a transparência referencial.";"Ambos são transparentes referencialmente.";"O paradigma lógico suporta a transparência referencial (sem efeitos colaterais), enquanto o imperativo é focado em modificar o estado, quebrando a transparência.";"Não há diferença entre eles.";"O paradigma lógico suporta a transparência referencial (sem efeitos colaterais), enquanto o imperativo é focado em modificar o estado, quebrando a transparência."
M9_Q5;9;"Qual é a diferença na abordagem para resolver um problema entre o 'paradigma imperativo' (Missão 4) e o 'paradigma lógico' (Missão 8)?";a;"O imperativo foca em uma sequência de comandos, o lógico em fatos e regras.";"O imperativo usa recursão e o lógico não.";"O imperativo é um paradigma declarativo.";"O lógico usa variáveis mutáveis, o imperativo não.";"Não há diferença significativa.";"O imperativo foca em uma sequência de comandos, o lógico em fatos e regras."
M9_Q6;9;"Como o conceito de 'fato' e 'regra' do paradigma lógico se relaciona com os 'sistemas de tipos' (Missão 3)?";c;"Fatos e regras são tipos de dados.";"Não há relação, são conceitos de paradigmas diferentes.";"A definição de fatos e regras em um programa lógico pode ser vista como uma forma de especificar a 'tipagem' ou 'relações' que são válidas no sistema.";"Sistemas de tipos são usados apenas em linguagens imperativas.";"Fatos e regras são exclusivos de linguagens fracamente tipadas.";"A definição de fatos e regras em um programa lógico pode ser vista como uma forma de especificar a 'tipagem' ou 'relações' que são válidas no sistema."
M9_Q7;9;"Qual a relação entre 'backtracking' (Missão 8) e a 'busca por soluções' no paradigma lógico?";b;"Backtracking é a mesma coisa que recursão de cauda.";"Backtracking é o mecanismo automático que permite ao interpretador 'voltar' e tentar caminhos alternativos na árvore de busca para encontrar soluções.";"Backtracking não é usado para encontrar soluções.";"Backtracking é um tipo de comando.";"Backtracking é um erro de compilação.";"Backtracking é o mecanismo automático que permite ao interpretador 'voltar' e tentar caminhos alternativos na árvore de busca para encontrar soluções."
M9_Q8;9;"Em relação aos 'sistemas de tipos' (Missão 3), por que o paradigma lógico não necessita de um sistema de tipos estáticos rigoroso?";e;"Porque ele usa variáveis mutáveis.";"Porque ele é um tipo de programação funcional.";"Porque ele é um paradigma imperativo.";"Porque ele não lida com dados.";"Porque a 'unificação' e a 'prova de teoremas' intrínsecas ao paradigma já atuam como uma forma de 'verificação' de consistência.";"Porque a 'unificação' e a 'prova de teoremas' intrínsecas ao paradigma já atuam como uma forma de 'verificação' de consistência."
M9_Q9;9;"Como o 'monomorfismo' (Missão 3) e o 'polimorfismo' (Missão 3) se aplicam ao paradigma lógico?";c;"O paradigma lógico não tem polimorfismo.";"O polimorfismo em lógica é o mesmo que em OO.";"O paradigma lógico utiliza um tipo de polimorfismo em que as variáveis podem assumir valores de diferentes tipos para satisfazer a unificação.";"O paradigma lógico é puramente monomórfico.";"O paradigma lógico usa polimorfismo de sobrecarga.";"O paradigma lógico utiliza um tipo de polimorfismo em que as variáveis podem assumir valores de diferentes tipos para satisfazer a unificação."
M9_Q10;9;"Em um programa lógico, qual a principal diferença entre 'fato' e 'regra'?";a;"Fato é uma proposição verdadeira conhecida, regra é uma forma de deduzir novos fatos.";"Não há diferença.";"Regras são sempre mais importantes que fatos.";"Fatos são dinâmicos e regras são estáticas.";"Fatos têm efeitos colaterais, regras não.";"Fato é uma proposição verdadeira conhecida, regra é uma forma de deduzir novos fatos."
M9_Q11;9;"Como o 'escopo dinâmico' (Missão 4) poderia ser comparado ao 'backtracking' (Missão 8)?";d;"Backtracking é um tipo de escopo dinâmico.";"O escopo dinâmico não tem relação com a busca.";"Ambos são conceitos de programação funcional.";"O escopo dinâmico se baseia no fluxo de execução, assim como o backtracking explora o fluxo de busca de soluções.";"Não há nenhuma relação entre os dois.";"O escopo dinâmico se baseia no fluxo de execução, assim como o backtracking explora o fluxo de busca de soluções."
M9_Q12;9;"Qual a principal vantagem do paradigma lógico para 'inteligência artificial' (Missão 8) em comparação com outros paradigmas?";e;"O paradigma lógico é mais rápido.";"Ele é uma forma de programação imperativa.";"Ele é menos expressivo.";"Ele é puramente funcional.";"Permite a representação de conhecimento e raciocínio lógico de forma declarativa, sendo ideal para sistemas especialistas e de prova de teoremas.";"Permite a representação de conhecimento e raciocínio lógico de forma declarativa, sendo ideal para sistemas especialistas e de prova de teoremas."
M9_Q13;9;"Por que o paradigma lógico é menos eficiente para 'cálculos numéricos' (Missão 8) que o paradigma imperativo?";b;"Ele é mais rápido.";"Porque sua abordagem de prova de teoremas não é otimizada para operações aritméticas, que são mais diretas em uma máquina de von Neumann.";"Porque ele não pode usar funções.";"Porque ele usa variáveis mutáveis.";"Não é menos eficiente.";"Porque sua abordagem de prova de teoremas não é otimizada para operações aritméticas, que são mais diretas em uma máquina de von Neumann."
M9_Q14;9;"Qual a relação entre os conceitos de 'comandos' (Missão 4) e 'regras de inferência' (Missão 8)?";c;"Comandos e regras são a mesma coisa.";"Comandos são usados para descrever o que fazer, regras para como fazer.";"Comandos alteram o estado do programa, enquanto regras são usadas para deduzir novos fatos sem alterar o estado.";"Regras são usados para a sintaxe, comandos para a semântica.";"Comandos só existem em linguagens lógicas.";"Comandos alteram o estado do programa, enquanto regras são usadas para deduzir novos fatos sem alterar o estado."
M9_Q15;9;"Como o conceito de 'valores de primeira classe' (Missão 3) se aplica ao paradigma lógico?";c;"Valores de primeira classe não se aplicam ao paradigma lógico.";"Valores de primeira classe são sempre mutáveis.";"O paradigma lógico foca em fatos e regras, e não em valores de primeira classe como funções, que são centrais no paradigma funcional.";"Valores de primeira classe são sempre números.";"Valores de primeira classe são exclusivos de linguagens imperativas.";"O paradigma lógico foca em fatos e regras, e não em valores de primeira classe como funções, que são centrais no paradigma funcional."
M9_Q16;9;"Qual a principal desvantagem do paradigma lógico em termos de 'legibilidade'?";e;"A legibilidade é sempre alta.";"Ele usa muitas variáveis mutáveis.";"Ele é muito parecido com a linguagem humana.";"Ele não usa recursão.";"A forma de expressar lógica e resolução de problemas pode ser não-intuitiva para programadores acostumados com o modelo imperativo.";"A forma de expressar lógica e resolução de problemas pode ser não-intuitiva para programadores acostumados com o modelo imperativo."
M9_Q17;9;"O que a 'semântica' (Missão 2) de uma linguagem lógica representa?";b;"A forma como o código é escrito.";"O significado das relações e fatos, e como o sistema infere novas conclusões a partir deles.";"O processo de otimização do código.";"A tradução para código de máquina.";"A alocação de memória.";"O significado das relações e fatos, e como o sistema infere novas conclusões a partir deles."
M9_Q18;9;"Qual a relação entre a 'arquitetura de von Neumann' (Missão 4) e o paradigma lógico (Missão 8)?";d;"O paradigma lógico é baseado na arquitetura de von Neumann.";"O paradigma lógico é o único paradigma adequado para a arquitetura.";"Não há relação, pois o paradigma lógico é um modelo de computação abstrato, não focado em estado e comandos.";"Não há uma relação direta, pois o paradigma lógico não é um modelo de execução sequencial baseado em estado mutável, como é o caso das linguagens imperativas.";"O paradigma lógico usa o mesmo modelo de memória que o paradigma imperativo.";"Não há uma relação direta, pois o paradigma lógico não é um modelo de execução sequencial baseado em estado mutável, como é o caso das linguagens imperativas."
M9_Q19;9;"O que o 'backtracking' no paradigma lógico tem em comum com o 'fluxo de controle' no paradigma imperativo?";c;"Ambos são formas de programação funcional.";"Ambos se baseiam em comandos de atribuição.";"Ambos são mecanismos para controlar o fluxo de execução, mas o backtracking é para a busca de soluções, enquanto o fluxo de controle imperativo é para a sequência de comandos.";"Ambos são usados para depurar o código.";"Não há nada em comum.";"Ambos são mecanismos para controlar o fluxo de execução, mas o backtracking é para a busca de soluções, enquanto o fluxo de controle imperativo é para a sequência de comandos."
M9_Q20;9;"Qual a principal diferença no tratamento de 'erros de tipo' entre uma linguagem com tipagem estática (Missão 3) e uma linguagem lógica como Prolog?";a;"A linguagem com tipagem estática detecta o erro em tempo de compilação, enquanto em Prolog a 'unificação' falha se a pergunta é inconsistente com os fatos.";"Ambos detectam erros de tipo em tempo de execução.";"Não há diferença.";"Prolog não tem erros de tipo.";"A linguagem com tipagem estática não tem erros.";"A linguagem com tipagem estática detecta o erro em tempo de compilação, enquanto em Prolog a 'unificação' falha se a pergunta é inconsistente com os fatos."